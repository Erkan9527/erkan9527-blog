<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://erkan9527.github.io/erkan9527-blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://erkan9527.github.io/erkan9527-blog/" rel="alternate" type="text/html" /><updated>2025-08-04T10:16:12+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/feed.xml</id><title type="html">Erkan9527</title><subtitle>格物致知
</subtitle><author><name>Erkan9527</name></author><entry><title type="html">Md5算法</title><link href="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-08-04-md5.html" rel="alternate" type="text/html" title="Md5算法" /><published>2025-08-04T00:00:00+00:00</published><updated>2025-08-04T00:00:00+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/md5</id><content type="html" xml:base="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-08-04-md5.html"><![CDATA[<p>MD5（Message Digest Algorithm 5）是一种广泛应用的哈希函数，常用于数据完整性校验、数字签名、密码存储等场景。以下从原理、实现、应用与安全性等多个角度详细介绍 MD5。</p>

<hr />

<h2 id="一md5-的基本原理">一、MD5 的基本原理</h2>

<p>MD5 是一种<strong>消息摘要算法</strong>，输入任意长度的数据，输出固定长度的 128 位（16 字节）哈希值。其核心目标是将大数据“压缩”为短小的摘要，且不同输入尽量产生不同输出。</p>

<h3 id="11-主要特性">1.1 主要特性</h3>
<ul>
  <li><strong>定长输出</strong>：无论输入多长，输出都是 128 位。</li>
  <li><strong>雪崩效应</strong>：输入微小变化，输出哈希值变化巨大。</li>
  <li><strong>不可逆性</strong>：理论上无法通过哈希值还原原始数据。</li>
  <li><strong>抗碰撞性</strong>：难以找到两个不同输入具有相同哈希值。</li>
</ul>

<hr />

<h2 id="二md5-的底层实现流程">二、MD5 的底层实现流程</h2>

<p>MD5 的底层实现分为以下几个步骤：</p>

<h3 id="21-数据填充padding">2.1 数据填充（Padding）</h3>
<ul>
  <li>先在消息末尾添加一个 <code class="language-plaintext highlighter-rouge">1</code> 位，然后补 <code class="language-plaintext highlighter-rouge">0</code>，直到长度对 512 取模等于 448。</li>
  <li>再补充 64 位，表示原始消息长度（单位：比特）。</li>
  <li>这样，最终消息长度是 512 的倍数。</li>
</ul>

<h3 id="22-初始化缓冲区">2.2 初始化缓冲区</h3>
<ul>
  <li>定义四个 32 位初始变量（A、B、C、D），分别为：
    <ul>
      <li>A = 0x67452301</li>
      <li>B = 0xefcdab89</li>
      <li>C = 0x98badcfe</li>
      <li>D = 0x10325476</li>
    </ul>
  </li>
</ul>

<h3 id="23-处理分组">2.3 处理分组</h3>
<ul>
  <li>将填充后的消息按 512 位（64 字节）分组，每组分为 16 个 32 位字。</li>
  <li>对每组数据进行 4 轮（Round）运算，每轮 16 步，总共 64 步。</li>
</ul>

<h3 id="24-非线性函数与常量">2.4 非线性函数与常量</h3>
<ul>
  <li>每轮使用不同的非线性函数（F、G、H、I）和常量表（T[i]）。</li>
  <li>每步操作包括：加法、位运算（与、或、非、异或）、循环左移。</li>
</ul>

<h3 id="25-输出结果">2.5 输出结果</h3>
<ul>
  <li>处理完所有分组后，将 A、B、C、D 拼接，得到最终的 128 位哈希值。</li>
</ul>

<hr />

<h2 id="三md5-的核心算法结构">三、MD5 的核心算法结构</h2>

<h3 id="31-四个非线性函数">3.1 四个非线性函数</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">&amp;</span> <span class="n">Y</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">X</span> <span class="o">&amp;</span> <span class="n">Z</span><span class="p">)</span>
<span class="n">G</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">&amp;</span> <span class="n">Z</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">Y</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">Z</span><span class="p">)</span>
<span class="n">H</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span> <span class="o">=</span> <span class="n">X</span> <span class="o">^</span> <span class="n">Y</span> <span class="o">^</span> <span class="n">Z</span>
<span class="n">I</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">^</span> <span class="p">(</span><span class="n">X</span> <span class="o">|</span> <span class="o">~</span><span class="n">Z</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="32-每轮操作">3.2 每轮操作</h3>
<p>每轮对 A、B、C、D 进行如下操作（以第一轮为例）：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="n">B</span> <span class="o">+</span> <span class="p">((</span><span class="n">A</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">D</span><span class="p">)</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">s</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">M[k]</code>：当前分组的第 k 个字</li>
  <li><code class="language-plaintext highlighter-rouge">T[i]</code>：常量表</li>
  <li><code class="language-plaintext highlighter-rouge">s</code>：循环左移位数</li>
</ul>

<hr />

<h2 id="四md5-的应用场景">四、MD5 的应用场景</h2>

<ul>
  <li><strong>文件完整性校验</strong>：下载文件时校验 MD5，防止篡改。</li>
  <li><strong>数字签名</strong>：与非对称加密结合，保证消息不可抵赖。</li>
  <li><strong>密码存储</strong>：对密码进行哈希存储（但已不推荐单独使用）。</li>
  <li><strong>唯一标识</strong>：为数据生成唯一标识符（如短链、去重等）。</li>
</ul>

<hr />

<h2 id="五md5-的安全性与局限">五、MD5 的安全性与局限</h2>

<h3 id="51-安全性问题">5.1 安全性问题</h3>
<ul>
  <li><strong>碰撞攻击</strong>：已被证明可以找到不同输入产生相同 MD5 值（2004 年被攻破）。</li>
  <li><strong>穷举攻击</strong>：128 位输出，理论上抗穷举，但计算能力提升后风险增加。</li>
  <li><strong>彩虹表攻击</strong>：针对常用密码的预计算哈希表，破解效率高。</li>
</ul>

<h3 id="52-现状与替代">5.2 现状与替代</h3>
<ul>
  <li><strong>不再推荐用于安全场景</strong>，如数字签名、密码存储等。</li>
  <li>推荐使用更安全的哈希算法，如 SHA-256、SHA-3、bcrypt、scrypt、Argon2 等。</li>
</ul>

<hr />

<h2 id="六md5-的拓展与变种">六、MD5 的拓展与变种</h2>

<ul>
  <li><strong>HMAC-MD5</strong>：结合密钥的消息认证码，用于数据完整性和认证。</li>
  <li><strong>MD4/MD2</strong>：MD5 的前身，安全性更弱。</li>
  <li><strong>MD6</strong>：设计为更安全的变种，但未被广泛采用。</li>
  <li><strong>与 SHA 系列对比</strong>：SHA-1、SHA-2、SHA-3 等在安全性和性能上各有优劣。</li>
</ul>

<hr />

<h2 id="七md5-的代码实现python-示例">七、MD5 的代码实现（Python 示例）</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">hashlib</span>

<span class="n">data</span> <span class="o">=</span> <span class="sh">"</span><span class="s">hello world</span><span class="sh">"</span>
<span class="n">md5_hash</span> <span class="o">=</span> <span class="n">hashlib</span><span class="p">.</span><span class="nf">md5</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">)).</span><span class="nf">hexdigest</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">md5_hash</span><span class="p">)</span>  <span class="c1"># 输出：5eb63bbbe01eeed093cb22bb8f5acdc3
</span></code></pre></div></div>

<hr />

<h2 id="八常见问题与误区">八、常见问题与误区</h2>

<ul>
  <li><strong>MD5 加密？</strong><br />
MD5 不是加密算法，而是哈希算法，不可逆。</li>
  <li><strong>MD5 能防篡改吗？</strong><br />
只能防止偶然错误，不能防止有意攻击。</li>
  <li><strong>MD5 还能用吗？</strong><br />
非安全场景（如文件校验）仍可用，安全场景应选用更强算法。</li>
</ul>

<hr />

<h2 id="九参考资料">九、参考资料</h2>

<ul>
  <li><a href="https://datatracker.ietf.org/doc/html/rfc1321">RFC 1321 - The MD5 Message-Digest Algorithm</a></li>
  <li><a href="https://www.mscs.dal.ca/~selinger/md5collision/">MD5 Collision Demo</a></li>
</ul>]]></content><author><name>Erkan9527</name></author><category term="技术" /><summary type="html"><![CDATA[MD5（Message Digest Algorithm 5）是一种广泛应用的哈希函数，常用于数据完整性校验、数字签名、密码存储等场景。以下从原理、实现、应用与安全性等多个角度详细介绍 MD5。]]></summary></entry><entry><title type="html">AOP注解实现参数校验</title><link href="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-22-aop.html" rel="alternate" type="text/html" title="AOP注解实现参数校验" /><published>2025-07-22T00:00:00+00:00</published><updated>2025-07-22T00:00:00+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/aop</id><content type="html" xml:base="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-22-aop.html"><![CDATA[<h1 id="aop-注解实现参数校验">AOP 注解实现参数校验</h1>

<p>在实际开发中，参数校验是一个非常常见的需求。传统的校验方式通常直接嵌入到业务逻辑中，导致代码耦合度高、可维护性差。而通过 <strong>AOP（面向切面编程）</strong> 和 <strong>反射</strong>，我们可以将参数校验逻辑从业务代码中解耦出来，实现统一的校验逻辑。</p>

<p>本文将通过一个完整的案例，展示如何使用 AOP 和自定义注解实现参数校验。</p>

<hr />

<h2 id="1-背景与需求">1. 背景与需求</h2>

<p>在业务开发中，我们经常需要对方法的参数进行校验，例如：</p>
<ul>
  <li>检查参数是否为 <code class="language-plaintext highlighter-rouge">null</code>。</li>
  <li>校验字符串是否为空或超出长度限制。</li>
  <li>验证参数是否符合特定规则（如邮箱格式、手机号格式等）。</li>
</ul>

<p>如果将这些校验逻辑直接写在业务方法中，会导致代码臃肿且难以复用。通过 AOP 和注解，我们可以实现以下目标：</p>
<ol>
  <li><strong>解耦校验逻辑</strong>：将校验逻辑从业务代码中分离。</li>
  <li><strong>增强复用性</strong>：校验逻辑可以在多个方法中复用。</li>
  <li><strong>提高可维护性</strong>：校验规则集中管理，便于扩展。</li>
</ol>

<hr />

<h2 id="2-实现步骤">2. 实现步骤</h2>

<h3 id="21-定义自定义注解">2.1 定义自定义注解</h3>

<p>首先，我们需要定义一个注解，用于标记需要校验的参数。例如，<code class="language-plaintext highlighter-rouge">@NotNull</code> 注解用于标记参数不能为空。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// filepath: /path/to/annotations/NotNull.java</span>
<span class="kn">package</span> <span class="nn">annotations</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.lang.annotation.ElementType</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.annotation.Retention</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.annotation.RetentionPolicy</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.annotation.Target</span><span class="o">;</span>

<span class="cm">/**
 * 标记参数不能为空的注解
 */</span>
<span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">PARAMETER</span><span class="o">)</span> <span class="c1">// 作用于方法参数</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span> <span class="c1">// 运行时可通过反射获取</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">NotNull</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">message</span><span class="o">()</span> <span class="k">default</span> <span class="s">"参数不能为空"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="22-创建-aop-切面">2.2 创建 AOP 切面</h3>

<p>接下来，我们需要创建一个 AOP 切面，用于拦截带有特定注解的方法，并对参数进行校验。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// filepath: /path/to/aspects/ValidationAspect.java</span>
<span class="kn">package</span> <span class="nn">aspects</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">annotations.NotNull</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.aspectj.lang.JoinPoint</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.aspectj.lang.annotation.Aspect</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.aspectj.lang.annotation.Before</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>

<span class="cm">/**
 * 参数校验切面
 */</span>
<span class="nd">@Aspect</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValidationAspect</span> <span class="o">{</span>

    <span class="nd">@Before</span><span class="o">(</span><span class="s">"execution(* your.package..*(.., @annotations.NotNull (*), ..))"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">validateNotNull</span><span class="o">(</span><span class="nc">JoinPoint</span> <span class="n">joinPoint</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span> <span class="o">=</span> <span class="n">joinPoint</span><span class="o">.</span><span class="na">getArgs</span><span class="o">();</span>
        <span class="nc">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="o">((</span><span class="nc">MethodSignature</span><span class="o">)</span> <span class="n">joinPoint</span><span class="o">.</span><span class="na">getSignature</span><span class="o">()).</span><span class="na">getMethod</span><span class="o">();</span>
        
        <span class="c1">// 获取方法参数注解</span>
        <span class="nc">Annotation</span><span class="o">[][]</span> <span class="n">paramAnnotations</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getParameterAnnotations</span><span class="o">();</span>
        
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">paramAnnotations</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Annotation</span> <span class="n">annotation</span> <span class="o">:</span> <span class="n">paramAnnotations</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">annotation</span> <span class="k">instanceof</span> <span class="nc">NotNull</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(((</span><span class="nc">NotNull</span><span class="o">)</span> <span class="n">annotation</span><span class="o">).</span><span class="na">message</span><span class="o">());</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="23-使用自定义注解">2.3 使用自定义注解</h3>

<p>最后，在业务代码中使用自定义的 <code class="language-plaintext highlighter-rouge">@NotNull</code> 注解标记需要校验的参数。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// filepath: /path/to/service/YourService.java</span>
<span class="kn">package</span> <span class="nn">service</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Service</span><span class="o">;</span>

<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">YourService</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">yourMethod</span><span class="o">(</span><span class="nd">@NotNull</span> <span class="nc">String</span> <span class="n">param</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 方法逻辑</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="3-总结">3. 总结</h2>

<p>通过 AOP 和自定义注解，我们可以方便地实现参数校验逻辑的解耦与复用。本文以 <code class="language-plaintext highlighter-rouge">@NotNull</code> 注解为例，演示了如何定义注解、创建 AOP 切面以及在业务代码中使用注解。实际应用中，我们可以根据需求定义更多的注解（如 <code class="language-plaintext highlighter-rouge">@MaxLength</code>、<code class="language-plaintext highlighter-rouge">@Email</code> 等），并在切面中实现相应的校验逻辑。</p>

<p>这种方式不仅提高了代码的可读性和可维护性，也使得参数校验逻辑更加灵活和强大。</p>]]></content><author><name>Erkan9527</name></author><category term="技术" /><summary type="html"><![CDATA[AOP 注解实现参数校验]]></summary></entry><entry><title type="html">TCP/IP网络模型</title><link href="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-21-TCPIP.html" rel="alternate" type="text/html" title="TCP/IP网络模型" /><published>2025-07-21T00:00:00+00:00</published><updated>2025-07-21T00:00:00+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/TCPIP</id><content type="html" xml:base="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-21-TCPIP.html"><![CDATA[<h2 id="tcpip-模型的核心概念">TCP/IP 模型的核心概念</h2>

<p>TCP/IP 模型通过分层结构实现网络通信的抽象与模块化。每一层负责特定功能，层与层之间协作，最终实现端到端的数据传输。</p>

<h3 id="关键点">关键点：</h3>
<ol>
  <li><strong>发送过程</strong>：数据从上层向下传递，每一层都会添加控制信息（即“首部”header），形成逐层封装的结构。</li>
  <li><strong>接收过程</strong>：数据从下层向上传递，每一层解析并移除自己的首部，最终还原为原始数据。</li>
</ol>

<hr />

<h3 id="数据通信流程">数据通信流程</h3>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">发送端（A）                ↓ 数据封装顺序
-------------------------------------------------------
</span>应用层       ← 你要发的内容（如网页请求 GET /index.html）
传输层       ← 加上 TCP/UDP 头（端口号、序列号等）
网络层       ← 加上 IP 头（源IP、目标IP等）
网络接口层   ← 加上 MAC 头尾（源MAC、目标MAC等）
<span class="gh">物理层       ← 转换成 0/1 电信号或无线信号发送出去
-------------------------------------------------------
</span>
</code></pre></div></div>

<hr />

<h3 id="各层的作用详解">各层的作用详解</h3>

<h4 id="1-应用层">1. 应用层</h4>
<ul>
  <li><strong>作用</strong>：为用户提供直接的网络服务，处理应用程序之间的通信。</li>
  <li><strong>典型协议</strong>：HTTP（网页浏览）、FTP（文件传输）、SMTP（邮件传输）。</li>
  <li><strong>功能</strong>：生成用户数据，并将其传递给传输层。</li>
</ul>

<h4 id="2-传输层">2. 传输层</h4>
<ul>
  <li><strong>作用</strong>：提供端到端的通信服务，确保数据可靠传输。</li>
  <li><strong>典型协议</strong>：TCP（面向连接，可靠传输）、UDP（无连接，快速传输）。</li>
  <li><strong>功能</strong>：
    <ul>
      <li>分割数据为段（Segment）。</li>
      <li>添加端口号，用于标识发送方和接收方的应用程序。</li>
      <li>提供错误检测和流量控制（TCP）。</li>
    </ul>
  </li>
</ul>

<h4 id="3-网络层">3. 网络层</h4>
<ul>
  <li><strong>作用</strong>：负责数据的路由选择和逻辑地址（IP 地址）管理。</li>
  <li><strong>典型协议</strong>：IP（IPv4/IPv6）、ICMP（网络诊断）、ARP（地址解析）。</li>
  <li><strong>功能</strong>：
    <ul>
      <li>将段封装为包（Packet）。</li>
      <li>添加源 IP 和目标 IP 地址。</li>
      <li>确定数据的最佳传输路径。</li>
    </ul>
  </li>
</ul>

<h5 id="子网掩码计算">子网掩码计算</h5>
<ul>
  <li><strong>子网掩码的作用</strong>：用于区分 IP 地址中的网络部分和主机部分，帮助确定数据包是否在同一子网内。</li>
  <li><strong>计算方法</strong>：
    <ol>
      <li><strong>子网划分</strong>：根据需求确定子网数量或主机数量。</li>
      <li><strong>子网掩码表示</strong>：以点分十进制（如 <code class="language-plaintext highlighter-rouge">255.255.255.0</code>）或 CIDR 表示法（如 <code class="language-plaintext highlighter-rouge">/24</code>）。</li>
      <li><strong>网络地址计算</strong>：将 IP 地址与子网掩码按位与（AND）运算，得到网络地址。</li>
      <li><strong>广播地址计算</strong>：将子网掩码取反后与 IP 地址按位或（OR）运算，得到广播地址。</li>
    </ol>
  </li>
  <li><strong>示例</strong>：
    <ul>
      <li>IP 地址：<code class="language-plaintext highlighter-rouge">192.168.1.10</code></li>
      <li>子网掩码：<code class="language-plaintext highlighter-rouge">255.255.255.0</code> 或 <code class="language-plaintext highlighter-rouge">/24</code></li>
      <li>网络地址计算：
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.1.10 (IP 地址)
AND 255.255.255.0 (子网掩码)
---------------------
192.168.1.0 (网络地址)
</code></pre></div>        </div>
      </li>
      <li>广播地址计算：
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.1.10 (IP 地址)
OR 0.0.0.255 (子网掩码取反)
---------------------
192.168.1.255 (广播地址)
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="4-链路层网络接口层">4. 链路层（网络接口层）</h4>
<ul>
  <li><strong>作用</strong>：负责物理网络上的数据传输，处理硬件地址（MAC 地址）。</li>
  <li><strong>典型协议</strong>：Ethernet（以太网）、Wi-Fi（无线局域网）。</li>
  <li><strong>功能</strong>：
    <ul>
      <li>将包封装为帧（Frame）。</li>
      <li>添加源 MAC 和目标 MAC 地址。</li>
      <li>提供错误检测（如 CRC 校验）。</li>
    </ul>
  </li>
</ul>

<h4 id="5-物理层">5. 物理层</h4>
<ul>
  <li><strong>作用</strong>：负责比特流的传输，定义硬件接口和信号标准。</li>
  <li><strong>典型技术</strong>：光纤、双绞线、无线电波。</li>
  <li><strong>功能</strong>：
    <ul>
      <li>将帧转换为电信号、光信号或无线信号。</li>
      <li>确保信号在物理介质上传输。</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="发送端封装">发送端（封装）：</h3>
<ol>
  <li><strong>应用层</strong>：生成用户数据。</li>
  <li><strong>传输层</strong>：添加传输层首部（如 TCP/UDP 头）。</li>
  <li><strong>网络层</strong>：添加网络层首部（如 IP 头）。</li>
  <li><strong>链路层</strong>：添加链路层首部和尾部（如 MAC 头/尾）。</li>
  <li><strong>最终形成帧</strong>：帧中包含包，包中包含段，段中是数据。</li>
</ol>

<h3 id="接收端解封装">接收端（解封装）：</h3>
<ol>
  <li><strong>链路层</strong>：移除 MAC 头/尾。</li>
  <li><strong>网络层</strong>：移除 IP 头。</li>
  <li><strong>传输层</strong>：移除 TCP/UDP 头。</li>
  <li><strong>应用层</strong>：还原为原始数据。</li>
</ol>

<hr />

<h3 id="总结">总结</h3>
<p>TCP/IP 模型的分层设计使得网络通信更加模块化和高效。每一层都有明确的职责，发送时逐层封装，接收时逐层解封装，确保数据能够准确传递并还原。</p>]]></content><author><name>Erkan9527</name></author><category term="技术" /><summary type="html"><![CDATA[TCP/IP 模型的核心概念]]></summary></entry><entry><title type="html">HTTP 协议详解</title><link href="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-21-http.html" rel="alternate" type="text/html" title="HTTP 协议详解" /><published>2025-07-21T00:00:00+00:00</published><updated>2025-07-21T00:00:00+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/http</id><content type="html" xml:base="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-21-http.html"><![CDATA[<h2 id="-一http-协议概述">🧠 一、HTTP 协议概述</h2>

<p>HTTP（HyperText Transfer Protocol）是客户端与服务器之间通信的标准协议，主要用于传输文本、图片、视频等资源。</p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>协议名称</strong></td>
      <td>HTTP（超文本传输协议）</td>
    </tr>
    <tr>
      <td><strong>主要作用</strong></td>
      <td>定义客户端与服务器之间的通信规则，传输资源</td>
    </tr>
    <tr>
      <td><strong>工作模式</strong></td>
      <td>客户端-服务器模型（C/S）</td>
    </tr>
    <tr>
      <td><strong>默认端口</strong></td>
      <td>80（HTTP），443（HTTPS）</td>
    </tr>
    <tr>
      <td><strong>基于协议</strong></td>
      <td>TCP（HTTP/1.1, 2），QUIC（HTTP/3）</td>
    </tr>
    <tr>
      <td><strong>特点</strong></td>
      <td>简单、无状态、可扩展</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-二http-与-https-的区别">🔐 二、HTTP 与 HTTPS 的区别</h2>

<table>
  <thead>
    <tr>
      <th>对比项</th>
      <th>HTTP</th>
      <th>HTTPS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>安全性</strong></td>
      <td>不加密，明文传输</td>
      <td>加密传输（基于 TLS/SSL）</td>
    </tr>
    <tr>
      <td><strong>端口</strong></td>
      <td>80</td>
      <td>443</td>
    </tr>
    <tr>
      <td><strong>数据完整性</strong></td>
      <td>无验证，易被篡改</td>
      <td>有完整性校验（如 HMAC）</td>
    </tr>
    <tr>
      <td><strong>身份验证</strong></td>
      <td>无</td>
      <td>有证书验证服务器身份</td>
    </tr>
    <tr>
      <td><strong>速度</strong></td>
      <td>快（但不安全）</td>
      <td>初次握手慢（需 TLS 握手），但数据安全</td>
    </tr>
    <tr>
      <td><strong>URL 前缀</strong></td>
      <td><code class="language-plaintext highlighter-rouge">http://</code></td>
      <td><code class="language-plaintext highlighter-rouge">https://</code></td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong>总结</strong>：HTTPS = HTTP + TLS/SSL + 证书</p>
</blockquote>

<hr />

<h2 id="-三http-各版本演进">📜 三、HTTP 各版本演进</h2>

<h3 id="-http09-1991最早版本">🔹 HTTP/0.9 （1991，最早版本）</h3>
<ul>
  <li><strong>特点</strong>：
    <ul>
      <li>仅支持 GET 请求。</li>
      <li>无响应头，直接返回 HTML 内容。</li>
      <li>无状态：请求完成后立即断开连接。</li>
    </ul>
  </li>
  <li><strong>适用场景</strong>：简单的静态文本网页。</li>
</ul>

<p><strong>示例</strong>：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /index.html
</code></pre></div></div>

<hr />

<h3 id="-http10-1996">🔹 HTTP/1.0 （1996）</h3>
<ul>
  <li><strong>特点</strong>：
    <ul>
      <li>引入请求/响应头（如 <code class="language-plaintext highlighter-rouge">Content-Type</code>、<code class="language-plaintext highlighter-rouge">Content-Length</code>）。</li>
      <li>支持多种方法：GET、POST、HEAD。</li>
      <li>每次请求建立一个 TCP 连接，频繁连接和断开导致性能低下。</li>
      <li>增加缓存支持：<code class="language-plaintext highlighter-rouge">Expires</code>、<code class="language-plaintext highlighter-rouge">Last-Modified</code>。</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="-http11-1997最广泛使用">🔹 HTTP/1.1 （1997，最广泛使用）</h3>
<ul>
  <li><strong>特点</strong>：
    <ul>
      <li><strong>长连接（Keep-Alive）</strong>：减少 TCP 连接的建立与关闭开销。</li>
      <li><strong>分块传输编码</strong>：支持不确定长度的响应数据。</li>
      <li><strong>管道化请求</strong>：同一连接中可发送多个请求（但需按顺序处理）。</li>
      <li><strong>请求头优化</strong>：支持 <code class="language-plaintext highlighter-rouge">Host</code> 字段，允许多个虚拟主机共享同一 IP。</li>
      <li><strong>缓存机制增强</strong>：引入 <code class="language-plaintext highlighter-rouge">ETag</code>、<code class="language-plaintext highlighter-rouge">Cache-Control</code> 等。</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="-http2-2015">🔹 HTTP/2 （2015）</h3>
<ul>
  <li><strong>特点</strong>：
    <ul>
      <li><strong>二进制传输</strong>：性能更高，取代纯文本格式。</li>
      <li><strong>多路复用（Multiplexing）</strong>：同一连接中多个请求并发处理，解决队头阻塞问题。</li>
      <li><strong>头部压缩（HPACK）</strong>：减少重复头部信息，提升传输效率。</li>
      <li><strong>服务器推送（Server Push）</strong>：服务器可主动推送资源到客户端。</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>优势</strong>：显著提升性能，尤其在移动端和弱网环境下表现优秀。</p>
</blockquote>

<hr />

<h3 id="-http32022最新">🔹 HTTP/3（2022，最新）</h3>
<ul>
  <li><strong>特点</strong>：
    <ul>
      <li><strong>基于 QUIC（UDP）</strong>：不再依赖 TCP，减少连接建立延迟。</li>
      <li><strong>连接迁移</strong>：支持 IP 地址变化（如移动网络切换）时保持连接。</li>
      <li><strong>快速握手</strong>：支持 0-RTT 和 1-RTT，显著加快连接建立速度。</li>
      <li><strong>解决 TCP 队头阻塞问题</strong>：每个流独立传输，不相互影响。</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="-四http-报文结构">📩 四、HTTP 报文结构</h2>

<h3 id="请求报文request">请求报文（Request）</h3>
<p>HTTP 请求报文由请求行、请求头和请求体组成。</p>

<p><strong>示例</strong>：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /index.html HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
Accept: text/html

（请求体 - 仅 POST/PUT 等方法有请求体）
</code></pre></div></div>

<h3 id="响应报文response">响应报文（Response）</h3>
<p>HTTP 响应报文由状态行、响应头和响应体组成。</p>

<p><strong>示例</strong>：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1024

&lt;html&gt;...&lt;/html&gt;
</code></pre></div></div>

<hr />

<h2 id="-五http-核心机制总结">✅ 五、HTTP 核心机制总结</h2>

<table>
  <thead>
    <tr>
      <th>概念</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>无状态</strong></td>
      <td>每次请求独立（可用 Cookie/Session 补充状态）。</td>
    </tr>
    <tr>
      <td><strong>方法</strong></td>
      <td>GET、POST、PUT、DELETE、HEAD、OPTIONS、PATCH 等。</td>
    </tr>
    <tr>
      <td><strong>状态码</strong></td>
      <td>200 成功，301/302 重定向，404 未找到，500 服务器错误等。</td>
    </tr>
    <tr>
      <td><strong>首部字段</strong></td>
      <td>常见字段包括 <code class="language-plaintext highlighter-rouge">Content-Type</code>、<code class="language-plaintext highlighter-rouge">User-Agent</code>、<code class="language-plaintext highlighter-rouge">Cache-Control</code> 等。</td>
    </tr>
    <tr>
      <td><strong>缓存机制</strong></td>
      <td>强缓存（<code class="language-plaintext highlighter-rouge">Expires</code>）、协商缓存（<code class="language-plaintext highlighter-rouge">ETag</code>）等。</td>
    </tr>
    <tr>
      <td><strong>重定向</strong></td>
      <td>301（永久重定向）、302（临时重定向）。</td>
    </tr>
    <tr>
      <td><strong>安全机制</strong></td>
      <td>HTTPS、CSP、HSTS、SameSite Cookie 等。</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-六http-与-https-总结对比">🆚 六、HTTP 与 HTTPS 总结对比</h2>

<table>
  <thead>
    <tr>
      <th>项目</th>
      <th>HTTP</th>
      <th>HTTPS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>加密</strong></td>
      <td>❌</td>
      <td>✅</td>
    </tr>
    <tr>
      <td><strong>端口</strong></td>
      <td>80</td>
      <td>443</td>
    </tr>
    <tr>
      <td><strong>SSL/TLS</strong></td>
      <td>❌</td>
      <td>✅</td>
    </tr>
    <tr>
      <td><strong>传输速度</strong></td>
      <td>快但不安全</td>
      <td>安全但首次握手稍慢</td>
    </tr>
    <tr>
      <td><strong>证书</strong></td>
      <td>无</td>
      <td>需要申请 CA 证书</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-七总结">📌 七、总结</h2>

<p>HTTP 是互联网通信的基础协议，其无状态、简单、可扩展的特点使其广泛应用于各种场景。随着版本的演进，HTTP 不断优化性能和安全性，尤其是 HTTP/2 和 HTTP/3 的引入，显著提升了传输效率和用户体验。HTTPS 的普及则进一步保障了数据传输的安全性，成为现代网络通信的主流选择。</p>]]></content><author><name>Erkan9527</name></author><category term="技术" /><summary type="html"><![CDATA[🧠 一、HTTP 协议概述]]></summary></entry><entry><title type="html">Java反射</title><link href="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-21-refect.html" rel="alternate" type="text/html" title="Java反射" /><published>2025-07-21T00:00:00+00:00</published><updated>2025-07-21T00:00:00+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/refect</id><content type="html" xml:base="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-21-refect.html"><![CDATA[<h1 id="java-反射详解">Java 反射详解</h1>

<h2 id="1-什么是反射">1. 什么是反射？</h2>
<p>反射（Reflection）是 Java 提供的一种机制，允许程序在运行时动态地获取类的结构信息（如类名、方法、字段、构造函数等），并对其进行操作。通过反射，程序可以在运行时加载类、调用方法、访问字段等，而无需在编译时明确指定。</p>

<hr />

<h2 id="2-反射的核心类">2. 反射的核心类</h2>
<p>反射的核心功能由以下类提供，这些类都位于 <code class="language-plaintext highlighter-rouge">java.lang.reflect</code> 包中：</p>

<table>
  <thead>
    <tr>
      <th><strong>类名</strong></th>
      <th><strong>描述</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Class</code></td>
      <td>表示类或接口的运行时信息，是反射的入口。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Field</code></td>
      <td>表示类的字段（成员变量），可用于获取或修改字段值。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Method</code></td>
      <td>表示类的方法，可用于调用方法。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Constructor</code></td>
      <td>表示类的构造函数，可用于创建对象实例。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Modifier</code></td>
      <td>提供静态方法，用于检查类或成员的修饰符（如 <code class="language-plaintext highlighter-rouge">public</code>、<code class="language-plaintext highlighter-rouge">static</code>）。</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="3-反射的核心功能">3. 反射的核心功能</h2>

<h3 id="31-获取-class-对象">3.1 获取 <code class="language-plaintext highlighter-rouge">Class</code> 对象</h3>
<p><code class="language-plaintext highlighter-rouge">Class</code> 是反射的入口，表示类的运行时信息。获取 <code class="language-plaintext highlighter-rouge">Class</code> 对象的方式有三种：</p>
<ul>
  <li><strong>方式 1</strong>：<code class="language-plaintext highlighter-rouge">Class.forName("类的全限定名")</code></li>
  <li><strong>方式 2</strong>：<code class="language-plaintext highlighter-rouge">类名.class</code></li>
  <li><strong>方式 3</strong>：<code class="language-plaintext highlighter-rouge">对象.getClass()</code></li>
</ul>

<hr />

<h3 id="32-获取类的基本信息">3.2 获取类的基本信息</h3>
<p>通过 <code class="language-plaintext highlighter-rouge">Class</code> 对象，可以获取类的基本信息：</p>
<ul>
  <li>类名、包名</li>
  <li>父类、实现的接口</li>
</ul>

<hr />

<h3 id="33-获取构造函数">3.3 获取构造函数</h3>
<p>通过 <code class="language-plaintext highlighter-rouge">Class</code> 对象，可以获取类的构造函数，并动态创建对象。</p>

<hr />

<h3 id="34-获取字段成员变量">3.4 获取字段（成员变量）</h3>
<p>通过 <code class="language-plaintext highlighter-rouge">Class</code> 对象，可以获取类的字段，并读取或修改字段值。</p>

<hr />

<h3 id="35-获取方法">3.5 获取方法</h3>
<p>通过 <code class="language-plaintext highlighter-rouge">Class</code> 对象，可以获取类的方法，并调用方法。</p>

<hr />

<h3 id="36-动态代理">3.6 动态代理</h3>
<p>动态代理是反射的重要应用之一，允许在运行时动态生成代理类，拦截方法调用。</p>

<hr />

<h2 id="4-反射的应用场景">4. 反射的应用场景</h2>
<p>反射在以下场景中非常有用：</p>
<ul>
  <li><strong>框架开发</strong>：如 Spring、Hibernate 等框架大量使用反射实现依赖注入、动态代理等功能。</li>
  <li><strong>动态加载类</strong>：如插件系统，可以在运行时加载和使用外部类。</li>
  <li><strong>序列化与反序列化</strong>：如 JSON/XML 序列化工具。</li>
  <li><strong>测试框架</strong>：如 JUnit 使用反射调用测试方法。</li>
  <li><strong>代码分析工具</strong>：如 IDE 的代码补全和静态分析功能。</li>
</ul>

<hr />

<h2 id="5-反射的优缺点">5. 反射的优缺点</h2>

<h3 id="优点">优点</h3>
<ul>
  <li><strong>灵活性</strong>：可以在运行时动态操作类和对象。</li>
  <li><strong>动态性</strong>：支持动态加载和调用，适合插件化开发。</li>
  <li><strong>通用性</strong>：可以编写通用代码，减少重复。</li>
</ul>

<h3 id="缺点">缺点</h3>
<ul>
  <li><strong>性能开销</strong>：反射操作比直接调用慢，可能影响性能。</li>
  <li><strong>安全性问题</strong>：可能破坏封装性，访问私有字段或方法。</li>
  <li><strong>代码复杂性</strong>：反射代码通常较难阅读和维护。</li>
</ul>

<hr />

<h2 id="6-反射的注意事项">6. 反射的注意事项</h2>
<ul>
  <li><strong>性能问题</strong>：反射操作较慢，尽量避免在性能敏感的场景中频繁使用。</li>
  <li><strong>安全性问题</strong>：滥用反射可能导致安全漏洞，尤其是访问私有成员。</li>
  <li><strong>兼容性问题</strong>：反射依赖于类的结构，类的修改可能导致反射代码失效。</li>
  <li><strong>访问限制</strong>：Java 9 及以上版本对反射访问做了更多限制（如模块化系统）。</li>
</ul>

<hr />

<h2 id="7-总结">7. 总结</h2>
<p>反射是 Java 提供的一种强大机制，允许程序在运行时动态操作类和对象。尽管反射带来了极大的灵活性，但也需要谨慎使用，避免性能和安全问题。在实际开发中，反射通常用于框架和工具的底层实现，而不是业务代码的常规操作。</p>]]></content><author><name>Erkan9527</name></author><category term="技术" /><summary type="html"><![CDATA[Java 反射详解]]></summary></entry><entry><title type="html">Redis 集群方案</title><link href="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redismothod.html" rel="alternate" type="text/html" title="Redis 集群方案" /><published>2025-07-19T00:00:00+00:00</published><updated>2025-07-19T00:00:00+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/redismothod</id><content type="html" xml:base="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redismothod.html"><![CDATA[<h1 id="redis-集群方案">Redis 集群方案</h1>

<p>Redis 是一种高性能的内存数据库，广泛应用于缓存、消息队列和实时数据处理等场景。随着业务规模的增长，单机 Redis 的性能和容量可能无法满足需求，因此需要采用分布式部署方案。本文记录了 Redis 主从模式、哨兵模式和集群模式的核心概念、优缺点及部署方式。</p>

<hr />

<h2 id="redis-主从模式">Redis 主从模式</h2>

<p>主从模式是一种经典的高可用部署方案，通过主节点和从节点的复制机制实现读写分离和数据冗余。主节点负责处理所有写操作，并将数据同步到从节点。从节点主要用于处理读操作，同时作为主节点的备份。一个主节点可以有多个从节点，从节点之间互不通信。</p>

<p>主从模式采用异步复制，主节点在写入数据后会异步地将数据同步到从节点。从 Redis 5.0 开始，支持部分同步（PSYNC），在网络中断后可以避免全量同步，提高效率。</p>

<p>主从模式的优点包括读写分离、数据冗余和高可用性。主节点处理写操作，从节点分担读操作，适合读多写少的场景。当主节点发生故障时，可以手动或自动将从节点提升为主节点，保证服务的连续性。</p>

<p>主从模式的部署相对简单，通常采用单主多从架构。主节点负责写操作，从节点分担读操作。如果需要更高的可用性，可以在主从模式的基础上引入哨兵机制。</p>

<hr />

<h2 id="redis-哨兵模式">Redis 哨兵模式</h2>

<p>哨兵模式是在主从模式的基础上，提供的一种高可用解决方案。哨兵通过监控主从节点的状态，实现自动化的主从切换和故障恢复，减少人工干预。</p>

<p>哨兵的核心功能包括监控、自动故障转移、配置提供和通知。哨兵会持续监控主节点和从节点的运行状态，定期发送 PING 命令检测节点是否正常响应。如果某个节点长时间未响应，哨兵会将其标记为下线。当主节点发生故障时，哨兵会自动从从节点中选举一个新的主节点，并通知其他从节点更新复制目标。同时，哨兵会将新的主节点信息通知客户端，确保客户端能够继续正常工作。</p>

<p>哨兵模式的架构包括主节点、从节点和哨兵节点。主节点负责写操作，从节点负责读操作并作为主节点的备份。哨兵节点是独立运行的进程，负责监控 Redis 集群的状态并执行故障转移。为了避免单点故障，通常需要部署多个哨兵节点（推荐至少 3 个）。</p>

<p>部署哨兵模式时，需要为每个哨兵节点创建配置文件，指定主节点信息和故障转移参数。启动哨兵节点后，哨兵会自动监控主从节点的状态，并在必要时执行故障转移。</p>

<hr />

<h2 id="redis-集群模式">Redis 集群模式</h2>

<p>Redis 集群模式是一种分布式部署方式，用于解决单机 Redis 在数据量和并发量上的限制。通过集群模式，Redis 可以实现数据分片和高可用性，适用于大规模、高性能的分布式系统。</p>

<p>Redis 集群将整个键空间划分为 16384 个槽（slot）。每个键通过 CRC16 哈希计算后取模，决定其所属的槽。每个节点负责一部分槽，数据分布均匀，避免单点瓶颈。集群通过主从复制实现高可用性，每个主节点可以有一个或多个从节点。当主节点发生故障时，从节点会自动提升为主节点，保证服务的连续性。</p>

<p>Redis 集群是无中心架构，每个节点都保存集群的元数据，并通过 Gossip 协议进行通信和状态同步。相比主从模式和哨兵模式，集群模式支持更大的数据量和更高的并发能力。</p>

<p>集群模式的优点包括水平扩展、高可用性、分布式存储和无中心架构。通过增加节点，可以轻松扩展存储容量和处理能力。主从复制和自动故障转移机制提高了系统的可靠性。分布式存储支持大规模数据存储，避免单机内存限制。无中心架构无需单点控制节点，集群更加稳定。</p>

<p>部署 Redis 集群时，需要准备至少 6 台服务器，每台运行一个 Redis 实例。在每个 Redis 实例的配置文件中，启用集群模式并指定节点端口。启动 Redis 实例后，可以使用 <code class="language-plaintext highlighter-rouge">redis-cli</code> 创建集群，并指定主从节点的分布。</p>

<hr />

<h2 id="总结">总结</h2>

<p>Redis 提供了多种高可用和分布式部署方案。主从模式适用于读多写少的场景，提供数据冗余和读写分离。哨兵模式在主从模式的基础上实现自动化故障恢复，适用于高可用性要求较高的系统。集群模式通过数据分片和无中心架构，解决单机性能瓶颈，适用于大规模分布式系统。</p>

<p>根据业务需求选择合适的方案，可以充分发挥 Redis 的性能和优势，构建高可用、高性能的分布式系统。</p>]]></content><author><name>Erkan9527</name></author><category term="技术" /><summary type="html"><![CDATA[Redis 集群方案]]></summary></entry><entry><title type="html">LRU缓存实现</title><link href="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-lru.html" rel="alternate" type="text/html" title="LRU缓存实现" /><published>2025-07-19T00:00:00+00:00</published><updated>2025-07-19T00:00:00+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/lru</id><content type="html" xml:base="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-lru.html"><![CDATA[<h2 id="题目">题目</h2>

<p><a href="https://leetcode.cn/problems/lru-cache/">LRU缓存</a></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LRUCache</span> <span class="p">{</span>
    <span class="nl">private:</span>
<span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
<span class="n">list</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="n">cache</span><span class="p">;</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">list</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span><span class="n">mp</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">LRUCache</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span><span class="o">:</span><span class="n">capacity</span><span class="p">(</span><span class="n">capacity</span><span class="p">){</span>
        
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">mp</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">==</span><span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">auto</span> <span class="n">it</span><span class="o">=</span><span class="n">mp</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">value</span><span class="o">=</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">push_front</span><span class="p">({</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">});</span>
        <span class="n">mp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">cache</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">mp</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">!=</span><span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
            <span class="k">auto</span> <span class="n">it</span><span class="o">=</span><span class="n">mp</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
            <span class="n">cache</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="n">capacity</span><span class="p">){</span>
        <span class="k">auto</span> <span class="n">it</span><span class="o">=</span><span class="n">cache</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
        <span class="n">mp</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
            <span class="n">cache</span><span class="p">.</span><span class="n">push_front</span><span class="p">({</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">});</span>
            <span class="n">mp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">cache</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

</code></pre></div></div>]]></content><author><name>Erkan9527</name></author><category term="技术" /><summary type="html"><![CDATA[题目]]></summary></entry><entry><title type="html">Redis 过期策略</title><link href="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redis-expiration-strategies.html" rel="alternate" type="text/html" title="Redis 过期策略" /><published>2025-07-19T00:00:00+00:00</published><updated>2025-07-19T00:00:00+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/redis-expiration-strategies</id><content type="html" xml:base="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redis-expiration-strategies.html"><![CDATA[<p>Redis 提供了灵活的过期管理策略和内存淘汰机制，用于高效管理键的生命周期和内存资源。本文记录了 Redis 的过期策略（Expiration Strategies）和内存淘汰策略（Eviction Policies）的核心概念、优缺点及适用场景。</p>

<hr />

<p>Redis 的过期策略用于管理带有过期时间的键，确保过期数据能够及时清理以释放内存资源。主要包括以下三种策略：</p>

<h3 id="定时删除fixed-interval-expiration">定时删除（Fixed Interval Expiration）</h3>

<p><strong>原理</strong><br />
为每个设置了过期时间的键创建一个定时器，当键的过期时间到达时，定时器触发并立即删除该键。</p>

<p><strong>优点</strong></p>
<ul>
  <li>确保内存及时释放，过期键会在设定时间点被立即移除。</li>
  <li>避免过期数据长时间占用内存资源。</li>
</ul>

<p><strong>缺点</strong></p>
<ul>
  <li>创建和管理大量定时器会消耗 CPU 资源，尤其是当系统中存在大量带有过期时间的键时，CPU 负载可能显著增加。</li>
  <li>如果定时器的精度不够高，可能导致键在预期时间之后才被删除。</li>
</ul>

<hr />

<h3 id="惰性删除lazy-expiration">惰性删除（Lazy Expiration）</h3>

<p><strong>原理</strong><br />
只有在访问某个键时，Redis 才会检查其是否已过期。如果已过期，则删除该键。</p>

<p><strong>优点</strong></p>
<ul>
  <li>不会占用额外的 CPU 资源进行检查，只在键被访问时才进行处理。</li>
  <li>对系统性能的影响较小。</li>
</ul>

<p><strong>缺点</strong></p>
<ul>
  <li>如果键从未被访问，即使已过期，也会一直保留在内存中，导致内存浪费。</li>
  <li>对于需要频繁访问的数据，可能会导致短时间内大量键被删除，从而影响系统性能。</li>
</ul>

<hr />

<h3 id="混合策略combined-policy">混合策略（Combined Policy）</h3>

<p><strong>原理</strong><br />
结合定时删除和惰性删除两种策略。Redis 会定期随机抽取一部分带有过期时间的键进行检查，并删除其中已过期的键；同时，在访问键时也会检查其是否已过期，如果已过期则删除该键。</p>

<p><strong>优点</strong></p>
<ul>
  <li>既能保证过期键及时被清理，又能尽量减少对系统性能的影响。</li>
  <li>通过合理设置扫描频率和每次扫描的耗时，可以在不同情况下平衡 CPU 和内存资源的使用。</li>
</ul>

<p><strong>缺点</strong></p>
<ul>
  <li>需要在 CPU 资源和内存资源之间做出权衡。</li>
  <li>配置复杂度较高，可能需要根据具体的应用场景调整参数以获得最佳效果。</li>
</ul>

<hr />

<h2 id="redis-内存淘汰策略">Redis 内存淘汰策略</h2>

<p>当 Redis 使用的内存达到预设的最大限制时，内存淘汰策略决定了哪些键值对应该被删除以释放空间。Redis 提供了多种内存淘汰策略，适用于不同的场景和需求。</p>

<h3 id="内存淘汰策略列表">内存淘汰策略列表</h3>

<ol>
  <li><strong>noeviction</strong>
    <ul>
      <li>默认策略（≥v3.0）。当内存使用达到最大限制时，Redis 拒绝新的写入操作并返回错误，仅响应读操作。</li>
      <li>适用场景：数据保留非常重要且不能丢失，或内存充足的环境。</li>
    </ul>
  </li>
  <li><strong>allkeys-lru</strong>
    <ul>
      <li>在所有键中使用 LRU（最近最少使用）算法进行淘汰。</li>
      <li>适用场景：缓存应用，需要保留最近被访问的数据以便快速响应后续请求。</li>
    </ul>
  </li>
  <li><strong>allkeys-lfu</strong>
    <ul>
      <li>在所有键中使用 LFU（最不经常使用）算法进行淘汰。</li>
      <li>适用场景：有明显热点数据的应用，确保热点数据不被轻易淘汰。</li>
    </ul>
  </li>
  <li><strong>volatile-lru</strong>
    <ul>
      <li>仅在设置了过期时间的键中，基于 LRU 算法淘汰数据。</li>
      <li>适用场景：部分数据有时效性要求，仅针对设置了过期时间的键进行淘汰。</li>
    </ul>
  </li>
  <li><strong>volatile-lfu</strong>
    <ul>
      <li>仅在设置了过期时间的键中，基于 LFU 算法淘汰数据。</li>
      <li>适用场景：同样只针对设置了过期时间的键，但淘汰依据是访问频率。</li>
    </ul>
  </li>
  <li><strong>allkeys-random</strong>
    <ul>
      <li>随机从所有键中淘汰数据。</li>
      <li>适用场景：对数据淘汰无特定要求。</li>
    </ul>
  </li>
  <li><strong>volatile-random</strong>
    <ul>
      <li>随机从设置了过期时间的键中淘汰数据。</li>
      <li>适用场景：仅针对设置了过期时间的键进行随机淘汰。</li>
    </ul>
  </li>
  <li><strong>volatile-ttl</strong>
    <ul>
      <li>根据键的剩余过期时间进行淘汰，越早过期的键越先被淘汰。</li>
      <li>适用场景：缓存数据时效性要求严格。</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="内存淘汰策略的选择">内存淘汰策略的选择</h2>

<table>
  <thead>
    <tr>
      <th>策略名称</th>
      <th>适用场景</th>
      <th>优点</th>
      <th>缺点</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>noeviction</td>
      <td>数据保留重要，内存充足</td>
      <td>数据不会被淘汰</td>
      <td>达到内存限制后无法写入新数据</td>
    </tr>
    <tr>
      <td>allkeys-lru</td>
      <td>缓存应用，保留最近访问的数据</td>
      <td>高效淘汰冷数据</td>
      <td>需要额外维护 LRU 数据结构</td>
    </tr>
    <tr>
      <td>allkeys-lfu</td>
      <td>热点数据明显，访问频率决定数据重要性</td>
      <td>确保热点数据不被淘汰</td>
      <td>需要额外维护 LFU 数据结构</td>
    </tr>
    <tr>
      <td>volatile-lru</td>
      <td>部分数据有时效性要求</td>
      <td>仅淘汰设置了过期时间的键</td>
      <td>仅适用于部分键有过期时间的场景</td>
    </tr>
    <tr>
      <td>volatile-lfu</td>
      <td>部分数据有时效性要求，访问频率决定淘汰顺序</td>
      <td>结合时效性和访问频率</td>
      <td>配置复杂度较高</td>
    </tr>
    <tr>
      <td>allkeys-random</td>
      <td>无特定淘汰要求</td>
      <td>简单随机淘汰</td>
      <td>数据淘汰不可控</td>
    </tr>
    <tr>
      <td>volatile-random</td>
      <td>无特定淘汰要求，针对有过期时间的键</td>
      <td>简单随机淘汰</td>
      <td>数据淘汰不可控</td>
    </tr>
    <tr>
      <td>volatile-ttl</td>
      <td>数据时效性要求严格</td>
      <td>优先淘汰即将过期的数据</td>
      <td>可能导致频繁淘汰操作</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="总结">总结</h2>

<p>Redis 的过期策略通过定时删除、惰性删除和混合策略三种方式管理带有过期时间的键，适用于不同的场景和需求。内存淘汰策略则提供了多种方式来优化内存使用，用户可以根据具体需求选择合适的策略。在实际使用中，合理配置过期策略和内存淘汰策略，并结合监控和调优，可以显著提升 Redis 的性能和资源利用率。</p>]]></content><author><name>Erkan9527</name></author><category term="技术" /><summary type="html"><![CDATA[Redis 提供了灵活的过期管理策略和内存淘汰机制，用于高效管理键的生命周期和内存资源。本文记录了 Redis 的过期策略（Expiration Strategies）和内存淘汰策略（Eviction Policies）的核心概念、优缺点及适用场景。]]></summary></entry><entry><title type="html">Redis 数据分片、事务机制与持久化机制</title><link href="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redis.html" rel="alternate" type="text/html" title="Redis 数据分片、事务机制与持久化机制" /><published>2025-07-19T00:00:00+00:00</published><updated>2025-07-19T00:00:00+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/redis</id><content type="html" xml:base="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redis.html"><![CDATA[<p>Redis 是一种高性能的内存数据库，广泛应用于缓存、消息队列和实时数据处理等场景。本文记录了 Redis 的数据分片、事务机制和持久化机制的核心概念与实现方式。</p>

<hr />

<h2 id="数据分片">数据分片</h2>

<h3 id="什么是-redis-的数据分片">什么是 Redis 的数据分片？</h3>

<p>Redis 的数据分片是一种将数据分布在多个节点上的技术，用于实现水平扩展和负载均衡。通过数据分片，Redis 可以在多个节点上并行处理请求，提高系统的吞吐量和容量，同时实现负载均衡和故障隔离。</p>

<h3 id="数据分片的实现方式">数据分片的实现方式</h3>

<ol>
  <li>
    <p><strong>哈希槽的定义</strong><br />
Redis 将整个数据空间划分为 16384 个哈希槽（Hash Slot），每个哈希槽都有一个唯一的标识符，从 0 到 16383。</p>
  </li>
  <li>
    <p><strong>数据的映射</strong><br />
客户端发送命令时，Redis Cluster 会通过 CRC16 哈希计算键的值，并将其映射到一个特定的哈希槽中。</p>
  </li>
  <li>
    <p><strong>哈希槽的分配</strong><br />
Redis Cluster 将所有哈希槽均匀分配给各个节点，每个节点负责存储一部分哈希槽对应的数据。</p>
  </li>
  <li>
    <p><strong>数据的查找</strong><br />
客户端访问某个键值对时，首先计算键的哈希值，找到对应的哈希槽，再根据哈希槽信息定位到负责该槽的节点。</p>
  </li>
  <li>
    <p><strong>数据的迁移</strong><br />
当集群需要添加或删除节点时，Redis Cluster 会进行数据迁移，重新分配哈希槽以保持负载均衡。</p>
  </li>
</ol>

<p>通过以上机制，Redis 实现了数据的水平扩展和高效分布式存储。</p>

<hr />

<h2 id="redis-为什么这么快">Redis 为什么这么快？</h2>

<p>Redis 的高性能主要得益于以下几个方面：</p>

<ol>
  <li>
    <p><strong>内存存储</strong><br />
Redis 将数据存储在内存中，避免了磁盘 I/O 的延迟，提供了极低的访问延迟和高吞吐量。</p>
  </li>
  <li>
    <p><strong>单线程模型</strong><br />
Redis 采用单线程模型，避免了多线程间的竞争和上下文切换的开销，简化了并发控制。</p>
  </li>
  <li>
    <p><strong>高效的数据结构</strong><br />
Redis 提供了多种优化的数据结构（如字符串、哈希表、跳跃表、集合、有序集合等），这些数据结构在插入、删除、查找和遍历操作上都经过了精心优化。</p>
  </li>
  <li>
    <p><strong>异步操作</strong><br />
Redis 支持异步操作，后台可以执行耗时任务（如持久化、复制等），减少客户端的等待时间。</p>
  </li>
  <li>
    <p><strong>高效的网络通信</strong><br />
Redis 使用自定义的 RESP 协议，结合非阻塞 I/O 多路复用机制和事件驱动模型，能够高效处理大量并发连接。</p>
  </li>
  <li>
    <p><strong>优化的算法和数据结构</strong><br />
Redis 内部使用了跳跃表（Skip List）、压缩列表（Ziplist）等优化算法和数据结构，进一步提升了性能。</p>
  </li>
</ol>

<p>这些特性使 Redis 能够在处理大量请求时保持低延迟和高吞吐量。</p>

<hr />

<h2 id="redis-的事务机制">Redis 的事务机制</h2>

<h3 id="redis-事务的基本概念">Redis 事务的基本概念</h3>

<p>Redis 的事务通过 <code class="language-plaintext highlighter-rouge">MULTI</code>、<code class="language-plaintext highlighter-rouge">EXEC</code>、<code class="language-plaintext highlighter-rouge">DISCARD</code> 和 <code class="language-plaintext highlighter-rouge">WATCH</code> 命令实现。事务可以将一组命令打包为一个原子操作，要么全部执行成功，要么全部失败。</p>

<h3 id="redis-事务的使用步骤">Redis 事务的使用步骤</h3>

<ol>
  <li>
    <p><strong>启动事务</strong><br />
使用 <code class="language-plaintext highlighter-rouge">MULTI</code> 命令启动事务，后续的命令会被放入事务队列中，而不是立即执行。</p>
  </li>
  <li>
    <p><strong>添加命令到事务队列</strong><br />
在调用 <code class="language-plaintext highlighter-rouge">MULTI</code> 后，可以发送多个命令，这些命令会被依次加入事务队列。</p>
  </li>
  <li>
    <p><strong>执行事务</strong><br />
使用 <code class="language-plaintext highlighter-rouge">EXEC</code> 命令执行事务队列中的所有命令。如果事务中的键被其他客户端修改，事务会失败。</p>
  </li>
  <li>
    <p><strong>取消事务</strong><br />
使用 <code class="language-plaintext highlighter-rouge">DISCARD</code> 命令取消事务，清空事务队列。</p>
  </li>
  <li>
    <p><strong>监视键（可选）</strong><br />
使用 <code class="language-plaintext highlighter-rouge">WATCH</code> 命令监视一个或多个键。如果在事务执行前这些键被修改，事务会被取消。</p>
  </li>
</ol>

<h3 id="示例">示例</h3>

<p>以下是一个 Redis 事务的示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 启动事务
MULTI

# 添加命令到事务队列
SET key1 value1
INCR key2

# 执行事务
EXEC
</code></pre></div></div>

<p>在这个示例中，<code class="language-plaintext highlighter-rouge">SET key1 value1</code> 和 <code class="language-plaintext highlighter-rouge">INCR key2</code> 这两个命令会被放入事务队列中，并在调用 <code class="language-plaintext highlighter-rouge">EXEC</code> 时一起执行。如果 <code class="language-plaintext highlighter-rouge">key2</code> 在 <code class="language-plaintext highlighter-rouge">EXEC</code> 执行之前被其他客户端修改了，那么整个事务会被取消。</p>

<h3 id="注意事项">注意事项</h3>

<ul>
  <li><strong>原子性</strong>: Redis 事务是原子性的，要么全部命令成功执行，要么全部失败。</li>
  <li><strong>隔离性</strong>: Redis 事务是串行化的，即在一个事务执行期间，不会有其他客户端能够看到中间状态。</li>
  <li><strong>一致性</strong>: Redis 事务保证数据库从一个一致的状态转换到另一个一致的状态。</li>
</ul>

<p>通过以上步骤和注意事项，你可以在 Redis 中有效地使用事务来确保数据的一致性和完整性。</p>

<hr />

<h2 id="redis的持久化机制">Redis的持久化机制</h2>

<p>Redis提供了两种主要的持久化机制，分别是RDB（Redis Database File）和AOF（Append Only File）。这两种机制各有优缺点，适用于不同的场景。以下是对这两种持久化机制的详细介绍：</p>

<h3 id="rdbredis-database-file持久化">RDB（Redis Database File）持久化</h3>

<ul>
  <li>
    <p><strong>概述</strong>：RDB是一种快照（Snapshot）形式的持久化方式。Redis会在指定的时间间隔内，将当前的内存数据快照保存为一个.rdb文件。这个文件可以用于Redis重启后的数据恢复。</p>
  </li>
  <li><strong>优点</strong>：
    <ul>
      <li>启动速度快：由于RDB文件是二进制的快照文件，Redis加载RDB文件的速度非常快。</li>
      <li>适合冷备份：RDB文件是一个压缩的二进制文件，适合将其复制到其他存储介质进行长期保存，尤其是灾难恢复的场景。</li>
      <li>占用空间小：相比AOF日志，RDB文件体积小，适合定期存储。</li>
    </ul>
  </li>
  <li><strong>缺点</strong>：
    <ul>
      <li>数据丢失风险：由于RDB是周期性保存快照的方式，如果Redis在快照之间发生宕机，最新的数据将会丢失。</li>
      <li>大数据集性能开销：在生成快照时，Redis需要fork子进程来执行持久化操作，如果数据集较大，fork过程会消耗较多资源，可能会影响性能。</li>
    </ul>
  </li>
  <li><strong>配置</strong>：RDB持久化的配置主要通过redis.conf文件中的save指令来设置。你可以根据需求设置保存快照的频率。</li>
</ul>

<h3 id="aofappend-only-file持久化">AOF（Append Only File）持久化</h3>

<ul>
  <li>
    <p><strong>概述</strong>：AOF是一种日志记录的持久化方式。Redis通过将每一个写操作记录到日志文件中，重启时可以通过重放日志文件中的命令来恢复数据。AOF记录的文件名通常是appendonly.aof。</p>
  </li>
  <li><strong>优点</strong>：
    <ul>
      <li>数据丢失最少：AOF可以设置成每次写操作后立即同步到磁盘，数据丢失的风险非常低。</li>
      <li>日志文件可读：AOF文件以文本格式保存，记录了所有写操作，方便审计和排查问题。</li>
      <li>重写机制：AOF支持日志文件重写，通过定期压缩日志文件，避免日志无限增长。</li>
    </ul>
  </li>
  <li><strong>缺点</strong>：
    <ul>
      <li>文件体积较大：由于AOF记录了每一次写操作，文件体积往往比RDB文件大很多。</li>
      <li>恢复速度较慢：AOF在重启时需要重放所有写操作，因此相较于RDB的快照恢复，速度较慢。</li>
      <li>性能开销大：如果配置为每次写操作都同步到磁盘，AOF的性能开销较高。</li>
    </ul>
  </li>
  <li><strong>配置</strong>：AOF持久化可以通过redis.conf中的以下配置项进行控制：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">appendonly yes</code>：开启AOF持久化。</li>
      <li><code class="language-plaintext highlighter-rouge">appendfilename "appendonly.aof"</code>：设置AOF文件名。</li>
      <li><code class="language-plaintext highlighter-rouge">appendfsync</code>：控制数据同步到磁盘的频率，可选值为always、everysec、no。</li>
    </ul>
  </li>
</ul>

<h3 id="rdb与aof对比表格">RDB与AOF对比表格</h3>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>RDB</th>
      <th>AOF</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>持久化方式</td>
      <td>快照形式，定期保存内存数据的快照</td>
      <td>日志形式，记录每个写操作命令</td>
    </tr>
    <tr>
      <td>启动速度</td>
      <td>快，因为只需加载二进制快照文件</td>
      <td>慢，因为需要重放所有写操作命令</td>
    </tr>
    <tr>
      <td>数据安全性</td>
      <td>较低，存在数据丢失风险</td>
      <td>较高，数据丢失风险极低</td>
    </tr>
    <tr>
      <td>文件大小</td>
      <td>较小，因为是压缩的二进制文件</td>
      <td>较大，因为记录了每个写操作命令</td>
    </tr>
    <tr>
      <td>适用场景</td>
      <td>适合冷备份和大规模数据恢复</td>
      <td>适合数据敏感场景和实时性要求高的应用</td>
    </tr>
    <tr>
      <td>性能开销</td>
      <td>fork子进程时有较大性能开销，但通常较快</td>
      <td>如果每次写操作都同步，性能开销较大</td>
    </tr>
  </tbody>
</table>

<p>RDB和AOF各有其优缺点，具体选择哪种持久化机制取决于业务需求。如果业务允许短暂的数据丢失，可以仅使用RDB持久化以减少性能开销；如果需要更高的可靠性，可以选择AOF，或者结合使用RDB和AOF混合模式。</p>]]></content><author><name>Erkan9527</name></author><category term="技术" /><summary type="html"><![CDATA[Redis 是一种高性能的内存数据库，广泛应用于缓存、消息队列和实时数据处理等场景。本文记录了 Redis 的数据分片、事务机制和持久化机制的核心概念与实现方式。]]></summary></entry><entry><title type="html">Redis 常见问题与解决方案</title><link href="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redisuse.html" rel="alternate" type="text/html" title="Redis 常见问题与解决方案" /><published>2025-07-19T00:00:00+00:00</published><updated>2025-07-19T00:00:00+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/redisuse</id><content type="html" xml:base="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redisuse.html"><![CDATA[<p>Redis 是一种高性能的内存数据库，广泛应用于缓存、分布式锁、消息队列等场景。然而，在实际使用中，可能会遇到一些常见问题，如热 Key、大 Key、缓存击穿、缓存穿透、缓存雪崩等。本文将对这些问题进行总结，并提供相应的解决方案。</p>

<hr />

<h2 id="热-key-问题">热 Key 问题</h2>

<h3 id="什么是热-key-问题">什么是热 Key 问题？</h3>
<p>热 Key 问题是指在短时间内大量请求集中访问 Redis 中的某个特定键，导致该键所在的节点负载过高，从而影响整个集群的性能和稳定性。</p>

<h3 id="解决方案">解决方案</h3>
<ol>
  <li>
    <p><strong>限流</strong><br />
对特定的 slot 或热 Key 进行限流，限制单位时间内的访问次数，减轻服务器压力。此方法适合紧急情况下使用，但可能对业务造成一定影响。</p>
  </li>
  <li>
    <p><strong>本地缓存</strong><br />
在应用层增加本地缓存（如 Guava Cache），将热点数据存储在本地内存中，减少对 Redis 的频繁访问，同时设置过期时间以保证数据一致性。</p>
  </li>
  <li>
    <p><strong>拆分 Key</strong><br />
将一个大的热点 Key 拆分成多个小的 Key，分散到不同的节点上。例如，将一个大的 List 拆分成多个小的 List，每个小 List 使用不同的 Key 存储。</p>
  </li>
</ol>

<hr />

<h2 id="大-key-问题">大 Key 问题</h2>

<h3 id="什么是大-key-问题">什么是大 Key 问题？</h3>
<p>大 Key 问题是指 Redis 中某个键值对占用了过多的内存，导致该键所在的节点负载过高，从而影响整个集群的性能和稳定性。</p>

<h3 id="解决方案-1">解决方案</h3>
<ol>
  <li>
    <p><strong>拆分大 Key</strong><br />
将一个大的 Key 拆分成多个小的 Key。例如，将一个大 List 或大 Hash 表拆分成多个小的 List 或 Hash 表。</p>
  </li>
  <li>
    <p><strong>压缩数据</strong><br />
对存储在 Redis 中的大对象进行压缩，减少内存占用。但需要注意压缩和解压缩操作会增加 CPU 负担。</p>
  </li>
  <li>
    <p><strong>优化数据结构</strong><br />
选择合适的数据结构存储数据。例如，使用 Sorted Set 替代 List 存储有序数据。</p>
  </li>
  <li>
    <p><strong>定期清理</strong><br />
对临时性的大 Key 设置合理的过期时间，或者定期扫描并清理大 Key。</p>
  </li>
</ol>

<hr />

<h2 id="缓存击穿缓存穿透与缓存雪崩">缓存击穿、缓存穿透与缓存雪崩</h2>

<h3 id="缓存击穿">缓存击穿</h3>
<p><strong>定义</strong><br />
缓存击穿是指在高并发情况下，当一个热点 Key 过期时，大量请求同时访问该 Key，导致这些请求直接穿透到数据库。</p>

<p><strong>解决方案</strong></p>
<ul>
  <li>设置热点数据永不过期。</li>
  <li>使用互斥锁或分布式锁，保证只有一个线程访问数据库，其他线程等待缓存更新完成。</li>
  <li>异步更新缓存，先返回旧数据，再异步更新缓存。</li>
</ul>

<hr />

<h3 id="缓存穿透">缓存穿透</h3>
<p><strong>定义</strong><br />
缓存穿透是指用户查询的数据在缓存和数据库中都不存在，导致请求直接穿透到数据库。</p>

<p><strong>解决方案</strong></p>
<ul>
  <li>缓存空对象：将查询结果为 null 的数据缓存，并设置较短的过期时间。</li>
  <li>参数校验：对输入参数进行校验，过滤非法请求。</li>
  <li>布隆过滤器：使用布隆过滤器快速判断数据是否存在，避免无效请求穿透到数据库。</li>
</ul>

<hr />

<h3 id="缓存雪崩">缓存雪崩</h3>
<p><strong>定义</strong><br />
缓存雪崩是指 Redis 实例宕机或大量缓存数据同时失效，导致大量请求直接打到数据库，造成数据库压力骤增甚至崩溃。</p>

<p><strong>解决方案</strong></p>
<ul>
  <li>分散缓存过期时间：为不同数据设置不同的过期时间，避免大量缓存同时失效。</li>
  <li>缓存预热：在系统上线前预先加载热点数据到缓存中。</li>
  <li>多级缓存：结合本地缓存和分布式缓存，减少对数据库的直接压力。</li>
  <li>限流与降级：限制请求频率，提供默认数据或降级服务。</li>
</ul>

<hr />

<h2 id="数据库与缓存不一致问题">数据库与缓存不一致问题</h2>

<h3 id="问题场景">问题场景</h3>
<ol>
  <li>写操作未更新缓存。</li>
  <li>缓存过期与数据库更新不同步。</li>
  <li>多级缓存之间的数据同步问题。</li>
  <li>数据库异常或缓存更新失败。</li>
</ol>

<h3 id="解决方案-2">解决方案</h3>
<ol>
  <li>
    <p><strong>双写策略</strong><br />
同时更新数据库和缓存，确保两者数据一致。需要注意幂等性和重试机制。</p>
  </li>
  <li>
    <p><strong>延时双删</strong><br />
更新数据库后，先删除缓存，再延时一段时间后再次删除缓存，确保高并发情况下数据一致性。</p>
  </li>
  <li>
    <p><strong>先更新数据库，再删除缓存</strong><br />
确保数据库中的数据总是最新的，然后删除缓存中的旧数据。</p>
  </li>
  <li>
    <p><strong>异步更新缓存</strong><br />
使用消息队列或 Canal 监听 MySQL binlog，将数据库变更异步同步到缓存。</p>
  </li>
</ol>

<hr />

<h2 id="redis-延迟消息">Redis 延迟消息</h2>

<h3 id="实现方式">实现方式</h3>
<ol>
  <li>
    <p><strong>使用 Sorted Set</strong><br />
将消息存储在 Sorted Set 中，分数设置为消息的执行时间戳，定期轮询处理到期消息。</p>
  </li>
  <li>
    <p><strong>使用 Redis Streams</strong><br />
利用 Redis Streams 数据结构和 Lua 脚本实现延迟消息队列。</p>
  </li>
  <li>
    <p><strong>使用第三方库</strong><br />
使用 Celery 等任务队列库，结合 Redis 实现延迟消息。</p>
  </li>
</ol>

<hr />

<h2 id="redis-的其他应用场景">Redis 的其他应用场景</h2>

<ol>
  <li>
    <p><strong>消息队列</strong><br />
使用 Redis 的发布/订阅功能实现简单的消息队列。</p>
  </li>
  <li>
    <p><strong>分布式锁</strong><br />
利用 Redis 的原子性操作和过期时间特性实现分布式锁。</p>
  </li>
  <li>
    <p><strong>计数器</strong><br />
使用 Redis 的自增/自减操作实现计数器功能。</p>
  </li>
  <li>
    <p><strong>地理位置应用</strong><br />
使用 Redis 的 Geo 数据结构存储和查询地理位置信息。</p>
  </li>
  <li>
    <p><strong>实时排行榜</strong><br />
利用 Redis 的有序集合实现实时排行榜。</p>
  </li>
</ol>

<hr />

<h2 id="分布式锁的实现">分布式锁的实现</h2>

<h3 id="使用-setnx-实现分布式锁">使用 SETNX 实现分布式锁</h3>
<ol>
  <li>
    <p><strong>原子性</strong><br />
SETNX 确保只有一个客户端能够成功设置锁。</p>
  </li>
  <li>
    <p><strong>过期时间</strong><br />
设置锁的过期时间，防止锁被永久占用。</p>
  </li>
  <li>
    <p><strong>示例代码</strong></p>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">redis</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">redis</span><span class="p">.</span><span class="nc">StrictRedis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="sh">'</span><span class="s">localhost</span><span class="sh">'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">,</span> <span class="n">db</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">acquire_lock</span><span class="p">(</span><span class="n">lock_key</span><span class="p">,</span> <span class="n">lock_timeout</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">now</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">())</span>
        <span class="n">lock_timeout</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">lock_timeout</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">.</span><span class="nf">setnx</span><span class="p">(</span><span class="n">lock_key</span><span class="p">,</span> <span class="n">lock_timeout</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="nf">int</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">lock_key</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">now</span><span class="p">:</span>
            <span class="n">r</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">lock_key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">release_lock</span><span class="p">(</span><span class="n">lock_key</span><span class="p">):</span>
    <span class="n">r</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">lock_key</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Erkan9527</name></author><category term="技术" /><summary type="html"><![CDATA[Redis 是一种高性能的内存数据库，广泛应用于缓存、分布式锁、消息队列等场景。然而，在实际使用中，可能会遇到一些常见问题，如热 Key、大 Key、缓存击穿、缓存穿透、缓存雪崩等。本文将对这些问题进行总结，并提供相应的解决方案。]]></summary></entry></feed>