<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://erkan9527.github.io/erkan9527-blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://erkan9527.github.io/erkan9527-blog/" rel="alternate" type="text/html" /><updated>2025-07-20T01:55:12+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/feed.xml</id><title type="html">Erkan9527</title><subtitle>格物致知
</subtitle><author><name>Erkan9527</name></author><entry><title type="html">Redis 集群方案</title><link href="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redismothod.html" rel="alternate" type="text/html" title="Redis 集群方案" /><published>2025-07-19T00:00:00+00:00</published><updated>2025-07-19T00:00:00+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/redismothod</id><content type="html" xml:base="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redismothod.html"><![CDATA[<h1 id="redis-集群方案">Redis 集群方案</h1>

<p>Redis 是一种高性能的内存数据库，广泛应用于缓存、消息队列和实时数据处理等场景。随着业务规模的增长，单机 Redis 的性能和容量可能无法满足需求，因此需要采用分布式部署方案。本文记录了 Redis 主从模式、哨兵模式和集群模式的核心概念、优缺点及部署方式。</p>

<hr />

<h2 id="redis-主从模式">Redis 主从模式</h2>

<p>主从模式是一种经典的高可用部署方案，通过主节点和从节点的复制机制实现读写分离和数据冗余。主节点负责处理所有写操作，并将数据同步到从节点。从节点主要用于处理读操作，同时作为主节点的备份。一个主节点可以有多个从节点，从节点之间互不通信。</p>

<p>主从模式采用异步复制，主节点在写入数据后会异步地将数据同步到从节点。从 Redis 5.0 开始，支持部分同步（PSYNC），在网络中断后可以避免全量同步，提高效率。</p>

<p>主从模式的优点包括读写分离、数据冗余和高可用性。主节点处理写操作，从节点分担读操作，适合读多写少的场景。当主节点发生故障时，可以手动或自动将从节点提升为主节点，保证服务的连续性。</p>

<p>主从模式的部署相对简单，通常采用单主多从架构。主节点负责写操作，从节点分担读操作。如果需要更高的可用性，可以在主从模式的基础上引入哨兵机制。</p>

<hr />

<h2 id="redis-哨兵模式">Redis 哨兵模式</h2>

<p>哨兵模式是在主从模式的基础上，提供的一种高可用解决方案。哨兵通过监控主从节点的状态，实现自动化的主从切换和故障恢复，减少人工干预。</p>

<p>哨兵的核心功能包括监控、自动故障转移、配置提供和通知。哨兵会持续监控主节点和从节点的运行状态，定期发送 PING 命令检测节点是否正常响应。如果某个节点长时间未响应，哨兵会将其标记为下线。当主节点发生故障时，哨兵会自动从从节点中选举一个新的主节点，并通知其他从节点更新复制目标。同时，哨兵会将新的主节点信息通知客户端，确保客户端能够继续正常工作。</p>

<p>哨兵模式的架构包括主节点、从节点和哨兵节点。主节点负责写操作，从节点负责读操作并作为主节点的备份。哨兵节点是独立运行的进程，负责监控 Redis 集群的状态并执行故障转移。为了避免单点故障，通常需要部署多个哨兵节点（推荐至少 3 个）。</p>

<p>部署哨兵模式时，需要为每个哨兵节点创建配置文件，指定主节点信息和故障转移参数。启动哨兵节点后，哨兵会自动监控主从节点的状态，并在必要时执行故障转移。</p>

<hr />

<h2 id="redis-集群模式">Redis 集群模式</h2>

<p>Redis 集群模式是一种分布式部署方式，用于解决单机 Redis 在数据量和并发量上的限制。通过集群模式，Redis 可以实现数据分片和高可用性，适用于大规模、高性能的分布式系统。</p>

<p>Redis 集群将整个键空间划分为 16384 个槽（slot）。每个键通过 CRC16 哈希计算后取模，决定其所属的槽。每个节点负责一部分槽，数据分布均匀，避免单点瓶颈。集群通过主从复制实现高可用性，每个主节点可以有一个或多个从节点。当主节点发生故障时，从节点会自动提升为主节点，保证服务的连续性。</p>

<p>Redis 集群是无中心架构，每个节点都保存集群的元数据，并通过 Gossip 协议进行通信和状态同步。相比主从模式和哨兵模式，集群模式支持更大的数据量和更高的并发能力。</p>

<p>集群模式的优点包括水平扩展、高可用性、分布式存储和无中心架构。通过增加节点，可以轻松扩展存储容量和处理能力。主从复制和自动故障转移机制提高了系统的可靠性。分布式存储支持大规模数据存储，避免单机内存限制。无中心架构无需单点控制节点，集群更加稳定。</p>

<p>部署 Redis 集群时，需要准备至少 6 台服务器，每台运行一个 Redis 实例。在每个 Redis 实例的配置文件中，启用集群模式并指定节点端口。启动 Redis 实例后，可以使用 <code class="language-plaintext highlighter-rouge">redis-cli</code> 创建集群，并指定主从节点的分布。</p>

<hr />

<h2 id="总结">总结</h2>

<p>Redis 提供了多种高可用和分布式部署方案。主从模式适用于读多写少的场景，提供数据冗余和读写分离。哨兵模式在主从模式的基础上实现自动化故障恢复，适用于高可用性要求较高的系统。集群模式通过数据分片和无中心架构，解决单机性能瓶颈，适用于大规模分布式系统。</p>

<p>根据业务需求选择合适的方案，可以充分发挥 Redis 的性能和优势，构建高可用、高性能的分布式系统。</p>]]></content><author><name>Erkan9527</name></author><category term="技术" /><summary type="html"><![CDATA[Redis 集群方案]]></summary></entry><entry><title type="html">LRU缓存实现</title><link href="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-lru.html" rel="alternate" type="text/html" title="LRU缓存实现" /><published>2025-07-19T00:00:00+00:00</published><updated>2025-07-19T00:00:00+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/lru</id><content type="html" xml:base="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-lru.html"><![CDATA[<h2 id="题目">题目</h2>

<p><a href="https://leetcode.cn/problems/lru-cache/">LRU缓存</a></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LRUCache</span> <span class="p">{</span>
    <span class="nl">private:</span>
<span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
<span class="n">list</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="n">cache</span><span class="p">;</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">list</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span><span class="n">mp</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">LRUCache</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span><span class="o">:</span><span class="n">capacity</span><span class="p">(</span><span class="n">capacity</span><span class="p">){</span>
        
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">mp</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">==</span><span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">auto</span> <span class="n">it</span><span class="o">=</span><span class="n">mp</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">value</span><span class="o">=</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">push_front</span><span class="p">({</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">});</span>
        <span class="n">mp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">cache</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">mp</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">!=</span><span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
            <span class="k">auto</span> <span class="n">it</span><span class="o">=</span><span class="n">mp</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
            <span class="n">cache</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="n">capacity</span><span class="p">){</span>
        <span class="k">auto</span> <span class="n">it</span><span class="o">=</span><span class="n">cache</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
        <span class="n">mp</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
            <span class="n">cache</span><span class="p">.</span><span class="n">push_front</span><span class="p">({</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">});</span>
            <span class="n">mp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">cache</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

</code></pre></div></div>]]></content><author><name>Erkan9527</name></author><category term="技术" /><summary type="html"><![CDATA[题目]]></summary></entry><entry><title type="html">Redis 过期策略</title><link href="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redis-expiration-strategies.html" rel="alternate" type="text/html" title="Redis 过期策略" /><published>2025-07-19T00:00:00+00:00</published><updated>2025-07-19T00:00:00+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/redis-expiration-strategies</id><content type="html" xml:base="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redis-expiration-strategies.html"><![CDATA[<p>Redis 提供了灵活的过期管理策略和内存淘汰机制，用于高效管理键的生命周期和内存资源。本文记录了 Redis 的过期策略（Expiration Strategies）和内存淘汰策略（Eviction Policies）的核心概念、优缺点及适用场景。</p>

<hr />

<p>Redis 的过期策略用于管理带有过期时间的键，确保过期数据能够及时清理以释放内存资源。主要包括以下三种策略：</p>

<h3 id="定时删除fixed-interval-expiration">定时删除（Fixed Interval Expiration）</h3>

<p><strong>原理</strong><br />
为每个设置了过期时间的键创建一个定时器，当键的过期时间到达时，定时器触发并立即删除该键。</p>

<p><strong>优点</strong></p>
<ul>
  <li>确保内存及时释放，过期键会在设定时间点被立即移除。</li>
  <li>避免过期数据长时间占用内存资源。</li>
</ul>

<p><strong>缺点</strong></p>
<ul>
  <li>创建和管理大量定时器会消耗 CPU 资源，尤其是当系统中存在大量带有过期时间的键时，CPU 负载可能显著增加。</li>
  <li>如果定时器的精度不够高，可能导致键在预期时间之后才被删除。</li>
</ul>

<hr />

<h3 id="惰性删除lazy-expiration">惰性删除（Lazy Expiration）</h3>

<p><strong>原理</strong><br />
只有在访问某个键时，Redis 才会检查其是否已过期。如果已过期，则删除该键。</p>

<p><strong>优点</strong></p>
<ul>
  <li>不会占用额外的 CPU 资源进行检查，只在键被访问时才进行处理。</li>
  <li>对系统性能的影响较小。</li>
</ul>

<p><strong>缺点</strong></p>
<ul>
  <li>如果键从未被访问，即使已过期，也会一直保留在内存中，导致内存浪费。</li>
  <li>对于需要频繁访问的数据，可能会导致短时间内大量键被删除，从而影响系统性能。</li>
</ul>

<hr />

<h3 id="混合策略combined-policy">混合策略（Combined Policy）</h3>

<p><strong>原理</strong><br />
结合定时删除和惰性删除两种策略。Redis 会定期随机抽取一部分带有过期时间的键进行检查，并删除其中已过期的键；同时，在访问键时也会检查其是否已过期，如果已过期则删除该键。</p>

<p><strong>优点</strong></p>
<ul>
  <li>既能保证过期键及时被清理，又能尽量减少对系统性能的影响。</li>
  <li>通过合理设置扫描频率和每次扫描的耗时，可以在不同情况下平衡 CPU 和内存资源的使用。</li>
</ul>

<p><strong>缺点</strong></p>
<ul>
  <li>需要在 CPU 资源和内存资源之间做出权衡。</li>
  <li>配置复杂度较高，可能需要根据具体的应用场景调整参数以获得最佳效果。</li>
</ul>

<hr />

<h2 id="redis-内存淘汰策略">Redis 内存淘汰策略</h2>

<p>当 Redis 使用的内存达到预设的最大限制时，内存淘汰策略决定了哪些键值对应该被删除以释放空间。Redis 提供了多种内存淘汰策略，适用于不同的场景和需求。</p>

<h3 id="内存淘汰策略列表">内存淘汰策略列表</h3>

<ol>
  <li><strong>noeviction</strong>
    <ul>
      <li>默认策略（≥v3.0）。当内存使用达到最大限制时，Redis 拒绝新的写入操作并返回错误，仅响应读操作。</li>
      <li>适用场景：数据保留非常重要且不能丢失，或内存充足的环境。</li>
    </ul>
  </li>
  <li><strong>allkeys-lru</strong>
    <ul>
      <li>在所有键中使用 LRU（最近最少使用）算法进行淘汰。</li>
      <li>适用场景：缓存应用，需要保留最近被访问的数据以便快速响应后续请求。</li>
    </ul>
  </li>
  <li><strong>allkeys-lfu</strong>
    <ul>
      <li>在所有键中使用 LFU（最不经常使用）算法进行淘汰。</li>
      <li>适用场景：有明显热点数据的应用，确保热点数据不被轻易淘汰。</li>
    </ul>
  </li>
  <li><strong>volatile-lru</strong>
    <ul>
      <li>仅在设置了过期时间的键中，基于 LRU 算法淘汰数据。</li>
      <li>适用场景：部分数据有时效性要求，仅针对设置了过期时间的键进行淘汰。</li>
    </ul>
  </li>
  <li><strong>volatile-lfu</strong>
    <ul>
      <li>仅在设置了过期时间的键中，基于 LFU 算法淘汰数据。</li>
      <li>适用场景：同样只针对设置了过期时间的键，但淘汰依据是访问频率。</li>
    </ul>
  </li>
  <li><strong>allkeys-random</strong>
    <ul>
      <li>随机从所有键中淘汰数据。</li>
      <li>适用场景：对数据淘汰无特定要求。</li>
    </ul>
  </li>
  <li><strong>volatile-random</strong>
    <ul>
      <li>随机从设置了过期时间的键中淘汰数据。</li>
      <li>适用场景：仅针对设置了过期时间的键进行随机淘汰。</li>
    </ul>
  </li>
  <li><strong>volatile-ttl</strong>
    <ul>
      <li>根据键的剩余过期时间进行淘汰，越早过期的键越先被淘汰。</li>
      <li>适用场景：缓存数据时效性要求严格。</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="内存淘汰策略的选择">内存淘汰策略的选择</h2>

<table>
  <thead>
    <tr>
      <th>策略名称</th>
      <th>适用场景</th>
      <th>优点</th>
      <th>缺点</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>noeviction</td>
      <td>数据保留重要，内存充足</td>
      <td>数据不会被淘汰</td>
      <td>达到内存限制后无法写入新数据</td>
    </tr>
    <tr>
      <td>allkeys-lru</td>
      <td>缓存应用，保留最近访问的数据</td>
      <td>高效淘汰冷数据</td>
      <td>需要额外维护 LRU 数据结构</td>
    </tr>
    <tr>
      <td>allkeys-lfu</td>
      <td>热点数据明显，访问频率决定数据重要性</td>
      <td>确保热点数据不被淘汰</td>
      <td>需要额外维护 LFU 数据结构</td>
    </tr>
    <tr>
      <td>volatile-lru</td>
      <td>部分数据有时效性要求</td>
      <td>仅淘汰设置了过期时间的键</td>
      <td>仅适用于部分键有过期时间的场景</td>
    </tr>
    <tr>
      <td>volatile-lfu</td>
      <td>部分数据有时效性要求，访问频率决定淘汰顺序</td>
      <td>结合时效性和访问频率</td>
      <td>配置复杂度较高</td>
    </tr>
    <tr>
      <td>allkeys-random</td>
      <td>无特定淘汰要求</td>
      <td>简单随机淘汰</td>
      <td>数据淘汰不可控</td>
    </tr>
    <tr>
      <td>volatile-random</td>
      <td>无特定淘汰要求，针对有过期时间的键</td>
      <td>简单随机淘汰</td>
      <td>数据淘汰不可控</td>
    </tr>
    <tr>
      <td>volatile-ttl</td>
      <td>数据时效性要求严格</td>
      <td>优先淘汰即将过期的数据</td>
      <td>可能导致频繁淘汰操作</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="总结">总结</h2>

<p>Redis 的过期策略通过定时删除、惰性删除和混合策略三种方式管理带有过期时间的键，适用于不同的场景和需求。内存淘汰策略则提供了多种方式来优化内存使用，用户可以根据具体需求选择合适的策略。在实际使用中，合理配置过期策略和内存淘汰策略，并结合监控和调优，可以显著提升 Redis 的性能和资源利用率。</p>]]></content><author><name>Erkan9527</name></author><category term="技术" /><summary type="html"><![CDATA[Redis 提供了灵活的过期管理策略和内存淘汰机制，用于高效管理键的生命周期和内存资源。本文记录了 Redis 的过期策略（Expiration Strategies）和内存淘汰策略（Eviction Policies）的核心概念、优缺点及适用场景。]]></summary></entry><entry><title type="html">Redis 数据分片、事务机制与持久化机制</title><link href="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redis.html" rel="alternate" type="text/html" title="Redis 数据分片、事务机制与持久化机制" /><published>2025-07-19T00:00:00+00:00</published><updated>2025-07-19T00:00:00+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/redis</id><content type="html" xml:base="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redis.html"><![CDATA[<p>Redis 是一种高性能的内存数据库，广泛应用于缓存、消息队列和实时数据处理等场景。本文记录了 Redis 的数据分片、事务机制和持久化机制的核心概念与实现方式。</p>

<hr />

<h2 id="数据分片">数据分片</h2>

<h3 id="什么是-redis-的数据分片">什么是 Redis 的数据分片？</h3>

<p>Redis 的数据分片是一种将数据分布在多个节点上的技术，用于实现水平扩展和负载均衡。通过数据分片，Redis 可以在多个节点上并行处理请求，提高系统的吞吐量和容量，同时实现负载均衡和故障隔离。</p>

<h3 id="数据分片的实现方式">数据分片的实现方式</h3>

<ol>
  <li>
    <p><strong>哈希槽的定义</strong><br />
Redis 将整个数据空间划分为 16384 个哈希槽（Hash Slot），每个哈希槽都有一个唯一的标识符，从 0 到 16383。</p>
  </li>
  <li>
    <p><strong>数据的映射</strong><br />
客户端发送命令时，Redis Cluster 会通过 CRC16 哈希计算键的值，并将其映射到一个特定的哈希槽中。</p>
  </li>
  <li>
    <p><strong>哈希槽的分配</strong><br />
Redis Cluster 将所有哈希槽均匀分配给各个节点，每个节点负责存储一部分哈希槽对应的数据。</p>
  </li>
  <li>
    <p><strong>数据的查找</strong><br />
客户端访问某个键值对时，首先计算键的哈希值，找到对应的哈希槽，再根据哈希槽信息定位到负责该槽的节点。</p>
  </li>
  <li>
    <p><strong>数据的迁移</strong><br />
当集群需要添加或删除节点时，Redis Cluster 会进行数据迁移，重新分配哈希槽以保持负载均衡。</p>
  </li>
</ol>

<p>通过以上机制，Redis 实现了数据的水平扩展和高效分布式存储。</p>

<hr />

<h2 id="redis-为什么这么快">Redis 为什么这么快？</h2>

<p>Redis 的高性能主要得益于以下几个方面：</p>

<ol>
  <li>
    <p><strong>内存存储</strong><br />
Redis 将数据存储在内存中，避免了磁盘 I/O 的延迟，提供了极低的访问延迟和高吞吐量。</p>
  </li>
  <li>
    <p><strong>单线程模型</strong><br />
Redis 采用单线程模型，避免了多线程间的竞争和上下文切换的开销，简化了并发控制。</p>
  </li>
  <li>
    <p><strong>高效的数据结构</strong><br />
Redis 提供了多种优化的数据结构（如字符串、哈希表、跳跃表、集合、有序集合等），这些数据结构在插入、删除、查找和遍历操作上都经过了精心优化。</p>
  </li>
  <li>
    <p><strong>异步操作</strong><br />
Redis 支持异步操作，后台可以执行耗时任务（如持久化、复制等），减少客户端的等待时间。</p>
  </li>
  <li>
    <p><strong>高效的网络通信</strong><br />
Redis 使用自定义的 RESP 协议，结合非阻塞 I/O 多路复用机制和事件驱动模型，能够高效处理大量并发连接。</p>
  </li>
  <li>
    <p><strong>优化的算法和数据结构</strong><br />
Redis 内部使用了跳跃表（Skip List）、压缩列表（Ziplist）等优化算法和数据结构，进一步提升了性能。</p>
  </li>
</ol>

<p>这些特性使 Redis 能够在处理大量请求时保持低延迟和高吞吐量。</p>

<hr />

<h2 id="redis-的事务机制">Redis 的事务机制</h2>

<h3 id="redis-事务的基本概念">Redis 事务的基本概念</h3>

<p>Redis 的事务通过 <code class="language-plaintext highlighter-rouge">MULTI</code>、<code class="language-plaintext highlighter-rouge">EXEC</code>、<code class="language-plaintext highlighter-rouge">DISCARD</code> 和 <code class="language-plaintext highlighter-rouge">WATCH</code> 命令实现。事务可以将一组命令打包为一个原子操作，要么全部执行成功，要么全部失败。</p>

<h3 id="redis-事务的使用步骤">Redis 事务的使用步骤</h3>

<ol>
  <li>
    <p><strong>启动事务</strong><br />
使用 <code class="language-plaintext highlighter-rouge">MULTI</code> 命令启动事务，后续的命令会被放入事务队列中，而不是立即执行。</p>
  </li>
  <li>
    <p><strong>添加命令到事务队列</strong><br />
在调用 <code class="language-plaintext highlighter-rouge">MULTI</code> 后，可以发送多个命令，这些命令会被依次加入事务队列。</p>
  </li>
  <li>
    <p><strong>执行事务</strong><br />
使用 <code class="language-plaintext highlighter-rouge">EXEC</code> 命令执行事务队列中的所有命令。如果事务中的键被其他客户端修改，事务会失败。</p>
  </li>
  <li>
    <p><strong>取消事务</strong><br />
使用 <code class="language-plaintext highlighter-rouge">DISCARD</code> 命令取消事务，清空事务队列。</p>
  </li>
  <li>
    <p><strong>监视键（可选）</strong><br />
使用 <code class="language-plaintext highlighter-rouge">WATCH</code> 命令监视一个或多个键。如果在事务执行前这些键被修改，事务会被取消。</p>
  </li>
</ol>

<h3 id="示例">示例</h3>

<p>以下是一个 Redis 事务的示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 启动事务
MULTI

# 添加命令到事务队列
SET key1 value1
INCR key2

# 执行事务
EXEC
</code></pre></div></div>

<p>在这个示例中，<code class="language-plaintext highlighter-rouge">SET key1 value1</code> 和 <code class="language-plaintext highlighter-rouge">INCR key2</code> 这两个命令会被放入事务队列中，并在调用 <code class="language-plaintext highlighter-rouge">EXEC</code> 时一起执行。如果 <code class="language-plaintext highlighter-rouge">key2</code> 在 <code class="language-plaintext highlighter-rouge">EXEC</code> 执行之前被其他客户端修改了，那么整个事务会被取消。</p>

<h3 id="注意事项">注意事项</h3>

<ul>
  <li><strong>原子性</strong>: Redis 事务是原子性的，要么全部命令成功执行，要么全部失败。</li>
  <li><strong>隔离性</strong>: Redis 事务是串行化的，即在一个事务执行期间，不会有其他客户端能够看到中间状态。</li>
  <li><strong>一致性</strong>: Redis 事务保证数据库从一个一致的状态转换到另一个一致的状态。</li>
</ul>

<p>通过以上步骤和注意事项，你可以在 Redis 中有效地使用事务来确保数据的一致性和完整性。</p>

<hr />

<h2 id="redis的持久化机制">Redis的持久化机制</h2>

<p>Redis提供了两种主要的持久化机制，分别是RDB（Redis Database File）和AOF（Append Only File）。这两种机制各有优缺点，适用于不同的场景。以下是对这两种持久化机制的详细介绍：</p>

<h3 id="rdbredis-database-file持久化">RDB（Redis Database File）持久化</h3>

<ul>
  <li>
    <p><strong>概述</strong>：RDB是一种快照（Snapshot）形式的持久化方式。Redis会在指定的时间间隔内，将当前的内存数据快照保存为一个.rdb文件。这个文件可以用于Redis重启后的数据恢复。</p>
  </li>
  <li><strong>优点</strong>：
    <ul>
      <li>启动速度快：由于RDB文件是二进制的快照文件，Redis加载RDB文件的速度非常快。</li>
      <li>适合冷备份：RDB文件是一个压缩的二进制文件，适合将其复制到其他存储介质进行长期保存，尤其是灾难恢复的场景。</li>
      <li>占用空间小：相比AOF日志，RDB文件体积小，适合定期存储。</li>
    </ul>
  </li>
  <li><strong>缺点</strong>：
    <ul>
      <li>数据丢失风险：由于RDB是周期性保存快照的方式，如果Redis在快照之间发生宕机，最新的数据将会丢失。</li>
      <li>大数据集性能开销：在生成快照时，Redis需要fork子进程来执行持久化操作，如果数据集较大，fork过程会消耗较多资源，可能会影响性能。</li>
    </ul>
  </li>
  <li><strong>配置</strong>：RDB持久化的配置主要通过redis.conf文件中的save指令来设置。你可以根据需求设置保存快照的频率。</li>
</ul>

<h3 id="aofappend-only-file持久化">AOF（Append Only File）持久化</h3>

<ul>
  <li>
    <p><strong>概述</strong>：AOF是一种日志记录的持久化方式。Redis通过将每一个写操作记录到日志文件中，重启时可以通过重放日志文件中的命令来恢复数据。AOF记录的文件名通常是appendonly.aof。</p>
  </li>
  <li><strong>优点</strong>：
    <ul>
      <li>数据丢失最少：AOF可以设置成每次写操作后立即同步到磁盘，数据丢失的风险非常低。</li>
      <li>日志文件可读：AOF文件以文本格式保存，记录了所有写操作，方便审计和排查问题。</li>
      <li>重写机制：AOF支持日志文件重写，通过定期压缩日志文件，避免日志无限增长。</li>
    </ul>
  </li>
  <li><strong>缺点</strong>：
    <ul>
      <li>文件体积较大：由于AOF记录了每一次写操作，文件体积往往比RDB文件大很多。</li>
      <li>恢复速度较慢：AOF在重启时需要重放所有写操作，因此相较于RDB的快照恢复，速度较慢。</li>
      <li>性能开销大：如果配置为每次写操作都同步到磁盘，AOF的性能开销较高。</li>
    </ul>
  </li>
  <li><strong>配置</strong>：AOF持久化可以通过redis.conf中的以下配置项进行控制：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">appendonly yes</code>：开启AOF持久化。</li>
      <li><code class="language-plaintext highlighter-rouge">appendfilename "appendonly.aof"</code>：设置AOF文件名。</li>
      <li><code class="language-plaintext highlighter-rouge">appendfsync</code>：控制数据同步到磁盘的频率，可选值为always、everysec、no。</li>
    </ul>
  </li>
</ul>

<h3 id="rdb与aof对比表格">RDB与AOF对比表格</h3>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>RDB</th>
      <th>AOF</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>持久化方式</td>
      <td>快照形式，定期保存内存数据的快照</td>
      <td>日志形式，记录每个写操作命令</td>
    </tr>
    <tr>
      <td>启动速度</td>
      <td>快，因为只需加载二进制快照文件</td>
      <td>慢，因为需要重放所有写操作命令</td>
    </tr>
    <tr>
      <td>数据安全性</td>
      <td>较低，存在数据丢失风险</td>
      <td>较高，数据丢失风险极低</td>
    </tr>
    <tr>
      <td>文件大小</td>
      <td>较小，因为是压缩的二进制文件</td>
      <td>较大，因为记录了每个写操作命令</td>
    </tr>
    <tr>
      <td>适用场景</td>
      <td>适合冷备份和大规模数据恢复</td>
      <td>适合数据敏感场景和实时性要求高的应用</td>
    </tr>
    <tr>
      <td>性能开销</td>
      <td>fork子进程时有较大性能开销，但通常较快</td>
      <td>如果每次写操作都同步，性能开销较大</td>
    </tr>
  </tbody>
</table>

<p>RDB和AOF各有其优缺点，具体选择哪种持久化机制取决于业务需求。如果业务允许短暂的数据丢失，可以仅使用RDB持久化以减少性能开销；如果需要更高的可靠性，可以选择AOF，或者结合使用RDB和AOF混合模式。</p>]]></content><author><name>Erkan9527</name></author><category term="技术" /><summary type="html"><![CDATA[Redis 是一种高性能的内存数据库，广泛应用于缓存、消息队列和实时数据处理等场景。本文记录了 Redis 的数据分片、事务机制和持久化机制的核心概念与实现方式。]]></summary></entry><entry><title type="html">Redis 常见问题与解决方案</title><link href="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redisuse.html" rel="alternate" type="text/html" title="Redis 常见问题与解决方案" /><published>2025-07-19T00:00:00+00:00</published><updated>2025-07-19T00:00:00+00:00</updated><id>https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/redisuse</id><content type="html" xml:base="https://erkan9527.github.io/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redisuse.html"><![CDATA[<p>Redis 是一种高性能的内存数据库，广泛应用于缓存、分布式锁、消息队列等场景。然而，在实际使用中，可能会遇到一些常见问题，如热 Key、大 Key、缓存击穿、缓存穿透、缓存雪崩等。本文将对这些问题进行总结，并提供相应的解决方案。</p>

<hr />

<h2 id="热-key-问题">热 Key 问题</h2>

<h3 id="什么是热-key-问题">什么是热 Key 问题？</h3>
<p>热 Key 问题是指在短时间内大量请求集中访问 Redis 中的某个特定键，导致该键所在的节点负载过高，从而影响整个集群的性能和稳定性。</p>

<h3 id="解决方案">解决方案</h3>
<ol>
  <li>
    <p><strong>限流</strong><br />
对特定的 slot 或热 Key 进行限流，限制单位时间内的访问次数，减轻服务器压力。此方法适合紧急情况下使用，但可能对业务造成一定影响。</p>
  </li>
  <li>
    <p><strong>本地缓存</strong><br />
在应用层增加本地缓存（如 Guava Cache），将热点数据存储在本地内存中，减少对 Redis 的频繁访问，同时设置过期时间以保证数据一致性。</p>
  </li>
  <li>
    <p><strong>拆分 Key</strong><br />
将一个大的热点 Key 拆分成多个小的 Key，分散到不同的节点上。例如，将一个大的 List 拆分成多个小的 List，每个小 List 使用不同的 Key 存储。</p>
  </li>
</ol>

<hr />

<h2 id="大-key-问题">大 Key 问题</h2>

<h3 id="什么是大-key-问题">什么是大 Key 问题？</h3>
<p>大 Key 问题是指 Redis 中某个键值对占用了过多的内存，导致该键所在的节点负载过高，从而影响整个集群的性能和稳定性。</p>

<h3 id="解决方案-1">解决方案</h3>
<ol>
  <li>
    <p><strong>拆分大 Key</strong><br />
将一个大的 Key 拆分成多个小的 Key。例如，将一个大 List 或大 Hash 表拆分成多个小的 List 或 Hash 表。</p>
  </li>
  <li>
    <p><strong>压缩数据</strong><br />
对存储在 Redis 中的大对象进行压缩，减少内存占用。但需要注意压缩和解压缩操作会增加 CPU 负担。</p>
  </li>
  <li>
    <p><strong>优化数据结构</strong><br />
选择合适的数据结构存储数据。例如，使用 Sorted Set 替代 List 存储有序数据。</p>
  </li>
  <li>
    <p><strong>定期清理</strong><br />
对临时性的大 Key 设置合理的过期时间，或者定期扫描并清理大 Key。</p>
  </li>
</ol>

<hr />

<h2 id="缓存击穿缓存穿透与缓存雪崩">缓存击穿、缓存穿透与缓存雪崩</h2>

<h3 id="缓存击穿">缓存击穿</h3>
<p><strong>定义</strong><br />
缓存击穿是指在高并发情况下，当一个热点 Key 过期时，大量请求同时访问该 Key，导致这些请求直接穿透到数据库。</p>

<p><strong>解决方案</strong></p>
<ul>
  <li>设置热点数据永不过期。</li>
  <li>使用互斥锁或分布式锁，保证只有一个线程访问数据库，其他线程等待缓存更新完成。</li>
  <li>异步更新缓存，先返回旧数据，再异步更新缓存。</li>
</ul>

<hr />

<h3 id="缓存穿透">缓存穿透</h3>
<p><strong>定义</strong><br />
缓存穿透是指用户查询的数据在缓存和数据库中都不存在，导致请求直接穿透到数据库。</p>

<p><strong>解决方案</strong></p>
<ul>
  <li>缓存空对象：将查询结果为 null 的数据缓存，并设置较短的过期时间。</li>
  <li>参数校验：对输入参数进行校验，过滤非法请求。</li>
  <li>布隆过滤器：使用布隆过滤器快速判断数据是否存在，避免无效请求穿透到数据库。</li>
</ul>

<hr />

<h3 id="缓存雪崩">缓存雪崩</h3>
<p><strong>定义</strong><br />
缓存雪崩是指 Redis 实例宕机或大量缓存数据同时失效，导致大量请求直接打到数据库，造成数据库压力骤增甚至崩溃。</p>

<p><strong>解决方案</strong></p>
<ul>
  <li>分散缓存过期时间：为不同数据设置不同的过期时间，避免大量缓存同时失效。</li>
  <li>缓存预热：在系统上线前预先加载热点数据到缓存中。</li>
  <li>多级缓存：结合本地缓存和分布式缓存，减少对数据库的直接压力。</li>
  <li>限流与降级：限制请求频率，提供默认数据或降级服务。</li>
</ul>

<hr />

<h2 id="数据库与缓存不一致问题">数据库与缓存不一致问题</h2>

<h3 id="问题场景">问题场景</h3>
<ol>
  <li>写操作未更新缓存。</li>
  <li>缓存过期与数据库更新不同步。</li>
  <li>多级缓存之间的数据同步问题。</li>
  <li>数据库异常或缓存更新失败。</li>
</ol>

<h3 id="解决方案-2">解决方案</h3>
<ol>
  <li>
    <p><strong>双写策略</strong><br />
同时更新数据库和缓存，确保两者数据一致。需要注意幂等性和重试机制。</p>
  </li>
  <li>
    <p><strong>延时双删</strong><br />
更新数据库后，先删除缓存，再延时一段时间后再次删除缓存，确保高并发情况下数据一致性。</p>
  </li>
  <li>
    <p><strong>先更新数据库，再删除缓存</strong><br />
确保数据库中的数据总是最新的，然后删除缓存中的旧数据。</p>
  </li>
  <li>
    <p><strong>异步更新缓存</strong><br />
使用消息队列或 Canal 监听 MySQL binlog，将数据库变更异步同步到缓存。</p>
  </li>
</ol>

<hr />

<h2 id="redis-延迟消息">Redis 延迟消息</h2>

<h3 id="实现方式">实现方式</h3>
<ol>
  <li>
    <p><strong>使用 Sorted Set</strong><br />
将消息存储在 Sorted Set 中，分数设置为消息的执行时间戳，定期轮询处理到期消息。</p>
  </li>
  <li>
    <p><strong>使用 Redis Streams</strong><br />
利用 Redis Streams 数据结构和 Lua 脚本实现延迟消息队列。</p>
  </li>
  <li>
    <p><strong>使用第三方库</strong><br />
使用 Celery 等任务队列库，结合 Redis 实现延迟消息。</p>
  </li>
</ol>

<hr />

<h2 id="redis-的其他应用场景">Redis 的其他应用场景</h2>

<ol>
  <li>
    <p><strong>消息队列</strong><br />
使用 Redis 的发布/订阅功能实现简单的消息队列。</p>
  </li>
  <li>
    <p><strong>分布式锁</strong><br />
利用 Redis 的原子性操作和过期时间特性实现分布式锁。</p>
  </li>
  <li>
    <p><strong>计数器</strong><br />
使用 Redis 的自增/自减操作实现计数器功能。</p>
  </li>
  <li>
    <p><strong>地理位置应用</strong><br />
使用 Redis 的 Geo 数据结构存储和查询地理位置信息。</p>
  </li>
  <li>
    <p><strong>实时排行榜</strong><br />
利用 Redis 的有序集合实现实时排行榜。</p>
  </li>
</ol>

<hr />

<h2 id="分布式锁的实现">分布式锁的实现</h2>

<h3 id="使用-setnx-实现分布式锁">使用 SETNX 实现分布式锁</h3>
<ol>
  <li>
    <p><strong>原子性</strong><br />
SETNX 确保只有一个客户端能够成功设置锁。</p>
  </li>
  <li>
    <p><strong>过期时间</strong><br />
设置锁的过期时间，防止锁被永久占用。</p>
  </li>
  <li>
    <p><strong>示例代码</strong></p>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">redis</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">redis</span><span class="p">.</span><span class="nc">StrictRedis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="sh">'</span><span class="s">localhost</span><span class="sh">'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">,</span> <span class="n">db</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">acquire_lock</span><span class="p">(</span><span class="n">lock_key</span><span class="p">,</span> <span class="n">lock_timeout</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">now</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">())</span>
        <span class="n">lock_timeout</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">lock_timeout</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">.</span><span class="nf">setnx</span><span class="p">(</span><span class="n">lock_key</span><span class="p">,</span> <span class="n">lock_timeout</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="nf">int</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">lock_key</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">now</span><span class="p">:</span>
            <span class="n">r</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">lock_key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">release_lock</span><span class="p">(</span><span class="n">lock_key</span><span class="p">):</span>
    <span class="n">r</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">lock_key</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Erkan9527</name></author><category term="技术" /><summary type="html"><![CDATA[Redis 是一种高性能的内存数据库，广泛应用于缓存、分布式锁、消息队列等场景。然而，在实际使用中，可能会遇到一些常见问题，如热 Key、大 Key、缓存击穿、缓存穿透、缓存雪崩等。本文将对这些问题进行总结，并提供相应的解决方案。]]></summary></entry></feed>