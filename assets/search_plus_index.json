{"/erkan9527-blog/contact/": {
    "title": "联系我",
    "keywords": "",
    "url": "/erkan9527-blog/contact/",
    "body": "联系我 如果您有任何问题或合作意向，可以通过以下方式联系我： 邮箱: yuanfox2024@163.com GitHub: Erkan9527"
  },"/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redisuse.html": {
    "title": "Redis 常见问题与解决方案",
    "keywords": "技术",
    "url": "/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redisuse.html",
    "body": "Redis 是一种高性能的内存数据库，广泛应用于缓存、分布式锁、消息队列等场景。然而，在实际使用中，可能会遇到一些常见问题，如热 Key、大 Key、缓存击穿、缓存穿透、缓存雪崩等。本文将对这些问题进行总结，并提供相应的解决方案。 热 Key 问题 什么是热 Key 问题？ 热 Key 问题是指在短时间内大量请求集中访问 Redis 中的某个特定键，导致该键所在的节点负载过高，从而影响整个集群的性能和稳定性。 解决方案 限流 对特定的 slot 或热 Key 进行限流，限制单位时间内的访问次数，减轻服务器压力。此方法适合紧急情况下使用，但可能对业务造成一定影响。 本地缓存 在应用层增加本地缓存（如 Guava Cache），将热点数据存储在本地内存中，减少对 Redis 的频繁访问，同时设置过期时间以保证数据一致性。 拆分 Key 将一个大的热点 Key 拆分成多个小的 Key，分散到不同的节点上。例如，将一个大的 List 拆分成多个小的 List，每个小 List 使用不同的 Key 存储。 大 Key 问题 什么是大 Key 问题？ 大 Key 问题是指 Redis 中某个键值对占用了过多的内存，导致该键所在的节点负载过高，从而影响整个集群的性能和稳定性。 解决方案 拆分大 Key 将一个大的 Key 拆分成多个小的 Key。例如，将一个大 List 或大 Hash 表拆分成多个小的 List 或 Hash 表。 压缩数据 对存储在 Redis 中的大对象进行压缩，减少内存占用。但需要注意压缩和解压缩操作会增加 CPU 负担。 优化数据结构 选择合适的数据结构存储数据。例如，使用 Sorted Set 替代 List 存储有序数据。 定期清理 对临时性的大 Key 设置合理的过期时间，或者定期扫描并清理大 Key。 缓存击穿、缓存穿透与缓存雪崩 缓存击穿 定义 缓存击穿是指在高并发情况下，当一个热点 Key 过期时，大量请求同时访问该 Key，导致这些请求直接穿透到数据库。 解决方案 设置热点数据永不过期。 使用互斥锁或分布式锁，保证只有一个线程访问数据库，其他线程等待缓存更新完成。 异步更新缓存，先返回旧数据，再异步更新缓存。 缓存穿透 定义 缓存穿透是指用户查询的数据在缓存和数据库中都不存在，导致请求直接穿透到数据库。 解决方案 缓存空对象：将查询结果为 null 的数据缓存，并设置较短的过期时间。 参数校验：对输入参数进行校验，过滤非法请求。 布隆过滤器：使用布隆过滤器快速判断数据是否存在，避免无效请求穿透到数据库。 缓存雪崩 定义 缓存雪崩是指 Redis 实例宕机或大量缓存数据同时失效，导致大量请求直接打到数据库，造成数据库压力骤增甚至崩溃。 解决方案 分散缓存过期时间：为不同数据设置不同的过期时间，避免大量缓存同时失效。 缓存预热：在系统上线前预先加载热点数据到缓存中。 多级缓存：结合本地缓存和分布式缓存，减少对数据库的直接压力。 限流与降级：限制请求频率，提供默认数据或降级服务。 数据库与缓存不一致问题 问题场景 写操作未更新缓存。 缓存过期与数据库更新不同步。 多级缓存之间的数据同步问题。 数据库异常或缓存更新失败。 解决方案 双写策略 同时更新数据库和缓存，确保两者数据一致。需要注意幂等性和重试机制。 延时双删 更新数据库后，先删除缓存，再延时一段时间后再次删除缓存，确保高并发情况下数据一致性。 先更新数据库，再删除缓存 确保数据库中的数据总是最新的，然后删除缓存中的旧数据。 异步更新缓存 使用消息队列或 Canal 监听 MySQL binlog，将数据库变更异步同步到缓存。 Redis 延迟消息 实现方式 使用 Sorted Set 将消息存储在 Sorted Set 中，分数设置为消息的执行时间戳，定期轮询处理到期消息。 使用 Redis Streams 利用 Redis Streams 数据结构和 Lua 脚本实现延迟消息队列。 使用第三方库 使用 Celery 等任务队列库，结合 Redis 实现延迟消息。 Redis 的其他应用场景 消息队列 使用 Redis 的发布/订阅功能实现简单的消息队列。 分布式锁 利用 Redis 的原子性操作和过期时间特性实现分布式锁。 计数器 使用 Redis 的自增/自减操作实现计数器功能。 地理位置应用 使用 Redis 的 Geo 数据结构存储和查询地理位置信息。 实时排行榜 利用 Redis 的有序集合实现实时排行榜。 分布式锁的实现 使用 SETNX 实现分布式锁 原子性 SETNX 确保只有一个客户端能够成功设置锁。 过期时间 设置锁的过期时间，防止锁被永久占用。 示例代码 import redis import time r = redis.StrictRedis(host='localhost', port=6379, db=0) def acquire_lock(lock_key, lock_timeout): while True: now = int(time.time()) lock_timeout = now + lock_timeout + 1 if r.setnx(lock_key, lock_timeout): return True elif int(r.get(lock_key)) &lt; now: r.delete(lock_key) else: time.sleep(0.001) def release_lock(lock_key): r.delete(lock_key)"
  },"/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redis.html": {
    "title": "Redis 数据分片、事务机制与持久化机制",
    "keywords": "技术",
    "url": "/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redis.html",
    "body": "Redis 是一种高性能的内存数据库，广泛应用于缓存、消息队列和实时数据处理等场景。本文记录了 Redis 的数据分片、事务机制和持久化机制的核心概念与实现方式。 数据分片 什么是 Redis 的数据分片？ Redis 的数据分片是一种将数据分布在多个节点上的技术，用于实现水平扩展和负载均衡。通过数据分片，Redis 可以在多个节点上并行处理请求，提高系统的吞吐量和容量，同时实现负载均衡和故障隔离。 数据分片的实现方式 哈希槽的定义 Redis 将整个数据空间划分为 16384 个哈希槽（Hash Slot），每个哈希槽都有一个唯一的标识符，从 0 到 16383。 数据的映射 客户端发送命令时，Redis Cluster 会通过 CRC16 哈希计算键的值，并将其映射到一个特定的哈希槽中。 哈希槽的分配 Redis Cluster 将所有哈希槽均匀分配给各个节点，每个节点负责存储一部分哈希槽对应的数据。 数据的查找 客户端访问某个键值对时，首先计算键的哈希值，找到对应的哈希槽，再根据哈希槽信息定位到负责该槽的节点。 数据的迁移 当集群需要添加或删除节点时，Redis Cluster 会进行数据迁移，重新分配哈希槽以保持负载均衡。 通过以上机制，Redis 实现了数据的水平扩展和高效分布式存储。 Redis 为什么这么快？ Redis 的高性能主要得益于以下几个方面： 内存存储 Redis 将数据存储在内存中，避免了磁盘 I/O 的延迟，提供了极低的访问延迟和高吞吐量。 单线程模型 Redis 采用单线程模型，避免了多线程间的竞争和上下文切换的开销，简化了并发控制。 高效的数据结构 Redis 提供了多种优化的数据结构（如字符串、哈希表、跳跃表、集合、有序集合等），这些数据结构在插入、删除、查找和遍历操作上都经过了精心优化。 异步操作 Redis 支持异步操作，后台可以执行耗时任务（如持久化、复制等），减少客户端的等待时间。 高效的网络通信 Redis 使用自定义的 RESP 协议，结合非阻塞 I/O 多路复用机制和事件驱动模型，能够高效处理大量并发连接。 优化的算法和数据结构 Redis 内部使用了跳跃表（Skip List）、压缩列表（Ziplist）等优化算法和数据结构，进一步提升了性能。 这些特性使 Redis 能够在处理大量请求时保持低延迟和高吞吐量。 Redis 的事务机制 Redis 事务的基本概念 Redis 的事务通过 MULTI、EXEC、DISCARD 和 WATCH 命令实现。事务可以将一组命令打包为一个原子操作，要么全部执行成功，要么全部失败。 Redis 事务的使用步骤 启动事务 使用 MULTI 命令启动事务，后续的命令会被放入事务队列中，而不是立即执行。 添加命令到事务队列 在调用 MULTI 后，可以发送多个命令，这些命令会被依次加入事务队列。 执行事务 使用 EXEC 命令执行事务队列中的所有命令。如果事务中的键被其他客户端修改，事务会失败。 取消事务 使用 DISCARD 命令取消事务，清空事务队列。 监视键（可选） 使用 WATCH 命令监视一个或多个键。如果在事务执行前这些键被修改，事务会被取消。 示例 以下是一个 Redis 事务的示例： # 启动事务 MULTI # 添加命令到事务队列 SET key1 value1 INCR key2 # 执行事务 EXEC 在这个示例中，SET key1 value1 和 INCR key2 这两个命令会被放入事务队列中，并在调用 EXEC 时一起执行。如果 key2 在 EXEC 执行之前被其他客户端修改了，那么整个事务会被取消。 注意事项 原子性: Redis 事务是原子性的，要么全部命令成功执行，要么全部失败。 隔离性: Redis 事务是串行化的，即在一个事务执行期间，不会有其他客户端能够看到中间状态。 一致性: Redis 事务保证数据库从一个一致的状态转换到另一个一致的状态。 通过以上步骤和注意事项，你可以在 Redis 中有效地使用事务来确保数据的一致性和完整性。 Redis的持久化机制 Redis提供了两种主要的持久化机制，分别是RDB（Redis Database File）和AOF（Append Only File）。这两种机制各有优缺点，适用于不同的场景。以下是对这两种持久化机制的详细介绍： RDB（Redis Database File）持久化 概述：RDB是一种快照（Snapshot）形式的持久化方式。Redis会在指定的时间间隔内，将当前的内存数据快照保存为一个.rdb文件。这个文件可以用于Redis重启后的数据恢复。 优点： 启动速度快：由于RDB文件是二进制的快照文件，Redis加载RDB文件的速度非常快。 适合冷备份：RDB文件是一个压缩的二进制文件，适合将其复制到其他存储介质进行长期保存，尤其是灾难恢复的场景。 占用空间小：相比AOF日志，RDB文件体积小，适合定期存储。 缺点： 数据丢失风险：由于RDB是周期性保存快照的方式，如果Redis在快照之间发生宕机，最新的数据将会丢失。 大数据集性能开销：在生成快照时，Redis需要fork子进程来执行持久化操作，如果数据集较大，fork过程会消耗较多资源，可能会影响性能。 配置：RDB持久化的配置主要通过redis.conf文件中的save指令来设置。你可以根据需求设置保存快照的频率。 AOF（Append Only File）持久化 概述：AOF是一种日志记录的持久化方式。Redis通过将每一个写操作记录到日志文件中，重启时可以通过重放日志文件中的命令来恢复数据。AOF记录的文件名通常是appendonly.aof。 优点： 数据丢失最少：AOF可以设置成每次写操作后立即同步到磁盘，数据丢失的风险非常低。 日志文件可读：AOF文件以文本格式保存，记录了所有写操作，方便审计和排查问题。 重写机制：AOF支持日志文件重写，通过定期压缩日志文件，避免日志无限增长。 缺点： 文件体积较大：由于AOF记录了每一次写操作，文件体积往往比RDB文件大很多。 恢复速度较慢：AOF在重启时需要重放所有写操作，因此相较于RDB的快照恢复，速度较慢。 性能开销大：如果配置为每次写操作都同步到磁盘，AOF的性能开销较高。 配置：AOF持久化可以通过redis.conf中的以下配置项进行控制： appendonly yes：开启AOF持久化。 appendfilename \"appendonly.aof\"：设置AOF文件名。 appendfsync：控制数据同步到磁盘的频率，可选值为always、everysec、no。 RDB与AOF对比表格 特性 RDB AOF 持久化方式 快照形式，定期保存内存数据的快照 日志形式，记录每个写操作命令 启动速度 快，因为只需加载二进制快照文件 慢，因为需要重放所有写操作命令 数据安全性 较低，存在数据丢失风险 较高，数据丢失风险极低 文件大小 较小，因为是压缩的二进制文件 较大，因为记录了每个写操作命令 适用场景 适合冷备份和大规模数据恢复 适合数据敏感场景和实时性要求高的应用 性能开销 fork子进程时有较大性能开销，但通常较快 如果每次写操作都同步，性能开销较大 RDB和AOF各有其优缺点，具体选择哪种持久化机制取决于业务需求。如果业务允许短暂的数据丢失，可以仅使用RDB持久化以减少性能开销；如果需要更高的可靠性，可以选择AOF，或者结合使用RDB和AOF混合模式。"
  },"/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redis-expiration-strategies.html": {
    "title": "Redis 过期策略",
    "keywords": "技术",
    "url": "/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redis-expiration-strategies.html",
    "body": "Redis 提供了灵活的过期管理策略和内存淘汰机制，用于高效管理键的生命周期和内存资源。本文记录了 Redis 的过期策略（Expiration Strategies）和内存淘汰策略（Eviction Policies）的核心概念、优缺点及适用场景。 Redis 的过期策略用于管理带有过期时间的键，确保过期数据能够及时清理以释放内存资源。主要包括以下三种策略： 定时删除（Fixed Interval Expiration） 原理 为每个设置了过期时间的键创建一个定时器，当键的过期时间到达时，定时器触发并立即删除该键。 优点 确保内存及时释放，过期键会在设定时间点被立即移除。 避免过期数据长时间占用内存资源。 缺点 创建和管理大量定时器会消耗 CPU 资源，尤其是当系统中存在大量带有过期时间的键时，CPU 负载可能显著增加。 如果定时器的精度不够高，可能导致键在预期时间之后才被删除。 惰性删除（Lazy Expiration） 原理 只有在访问某个键时，Redis 才会检查其是否已过期。如果已过期，则删除该键。 优点 不会占用额外的 CPU 资源进行检查，只在键被访问时才进行处理。 对系统性能的影响较小。 缺点 如果键从未被访问，即使已过期，也会一直保留在内存中，导致内存浪费。 对于需要频繁访问的数据，可能会导致短时间内大量键被删除，从而影响系统性能。 混合策略（Combined Policy） 原理 结合定时删除和惰性删除两种策略。Redis 会定期随机抽取一部分带有过期时间的键进行检查，并删除其中已过期的键；同时，在访问键时也会检查其是否已过期，如果已过期则删除该键。 优点 既能保证过期键及时被清理，又能尽量减少对系统性能的影响。 通过合理设置扫描频率和每次扫描的耗时，可以在不同情况下平衡 CPU 和内存资源的使用。 缺点 需要在 CPU 资源和内存资源之间做出权衡。 配置复杂度较高，可能需要根据具体的应用场景调整参数以获得最佳效果。 Redis 内存淘汰策略 当 Redis 使用的内存达到预设的最大限制时，内存淘汰策略决定了哪些键值对应该被删除以释放空间。Redis 提供了多种内存淘汰策略，适用于不同的场景和需求。 内存淘汰策略列表 noeviction 默认策略（≥v3.0）。当内存使用达到最大限制时，Redis 拒绝新的写入操作并返回错误，仅响应读操作。 适用场景：数据保留非常重要且不能丢失，或内存充足的环境。 allkeys-lru 在所有键中使用 LRU（最近最少使用）算法进行淘汰。 适用场景：缓存应用，需要保留最近被访问的数据以便快速响应后续请求。 allkeys-lfu 在所有键中使用 LFU（最不经常使用）算法进行淘汰。 适用场景：有明显热点数据的应用，确保热点数据不被轻易淘汰。 volatile-lru 仅在设置了过期时间的键中，基于 LRU 算法淘汰数据。 适用场景：部分数据有时效性要求，仅针对设置了过期时间的键进行淘汰。 volatile-lfu 仅在设置了过期时间的键中，基于 LFU 算法淘汰数据。 适用场景：同样只针对设置了过期时间的键，但淘汰依据是访问频率。 allkeys-random 随机从所有键中淘汰数据。 适用场景：对数据淘汰无特定要求。 volatile-random 随机从设置了过期时间的键中淘汰数据。 适用场景：仅针对设置了过期时间的键进行随机淘汰。 volatile-ttl 根据键的剩余过期时间进行淘汰，越早过期的键越先被淘汰。 适用场景：缓存数据时效性要求严格。 内存淘汰策略的选择 策略名称 适用场景 优点 缺点 noeviction 数据保留重要，内存充足 数据不会被淘汰 达到内存限制后无法写入新数据 allkeys-lru 缓存应用，保留最近访问的数据 高效淘汰冷数据 需要额外维护 LRU 数据结构 allkeys-lfu 热点数据明显，访问频率决定数据重要性 确保热点数据不被淘汰 需要额外维护 LFU 数据结构 volatile-lru 部分数据有时效性要求 仅淘汰设置了过期时间的键 仅适用于部分键有过期时间的场景 volatile-lfu 部分数据有时效性要求，访问频率决定淘汰顺序 结合时效性和访问频率 配置复杂度较高 allkeys-random 无特定淘汰要求 简单随机淘汰 数据淘汰不可控 volatile-random 无特定淘汰要求，针对有过期时间的键 简单随机淘汰 数据淘汰不可控 volatile-ttl 数据时效性要求严格 优先淘汰即将过期的数据 可能导致频繁淘汰操作 总结 Redis 的过期策略通过定时删除、惰性删除和混合策略三种方式管理带有过期时间的键，适用于不同的场景和需求。内存淘汰策略则提供了多种方式来优化内存使用，用户可以根据具体需求选择合适的策略。在实际使用中，合理配置过期策略和内存淘汰策略，并结合监控和调优，可以显著提升 Redis 的性能和资源利用率。"
  },"/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-lru.html": {
    "title": "LRU缓存实现",
    "keywords": "技术",
    "url": "/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-lru.html",
    "body": "题目 LRU缓存 class LRUCache { private: int capacity; list&lt;pair&lt;int,int&gt;&gt;cache; unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator&gt;mp; public: LRUCache(int capacity):capacity(capacity){ } int get(int key) { if(mp.find(key)==mp.end()){ return -1; } auto it=mp[key]; int value=it-&gt;second; cache.erase(it); cache.push_front({key,value}); mp[key]=cache.begin(); return value; } void put(int key, int value) { if(mp.find(key)!=mp.end()){ auto it=mp[key]; cache.erase(it); } else{ if(cache.size()==capacity){ auto it=cache.back(); mp.erase(it.first); cache.pop_back(); } } cache.push_front({key,value}); mp[key]=cache.begin(); } };"
  },"/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redismothod.html": {
    "title": "Redis 集群方案",
    "keywords": "技术",
    "url": "/erkan9527-blog/%E6%8A%80%E6%9C%AF/2025-07-19-redismothod.html",
    "body": "Redis 集群方案 Redis 是一种高性能的内存数据库，广泛应用于缓存、消息队列和实时数据处理等场景。随着业务规模的增长，单机 Redis 的性能和容量可能无法满足需求，因此需要采用分布式部署方案。本文记录了 Redis 主从模式、哨兵模式和集群模式的核心概念、优缺点及部署方式。 Redis 主从模式 主从模式是一种经典的高可用部署方案，通过主节点和从节点的复制机制实现读写分离和数据冗余。主节点负责处理所有写操作，并将数据同步到从节点。从节点主要用于处理读操作，同时作为主节点的备份。一个主节点可以有多个从节点，从节点之间互不通信。 主从模式采用异步复制，主节点在写入数据后会异步地将数据同步到从节点。从 Redis 5.0 开始，支持部分同步（PSYNC），在网络中断后可以避免全量同步，提高效率。 主从模式的优点包括读写分离、数据冗余和高可用性。主节点处理写操作，从节点分担读操作，适合读多写少的场景。当主节点发生故障时，可以手动或自动将从节点提升为主节点，保证服务的连续性。 主从模式的部署相对简单，通常采用单主多从架构。主节点负责写操作，从节点分担读操作。如果需要更高的可用性，可以在主从模式的基础上引入哨兵机制。 Redis 哨兵模式 哨兵模式是在主从模式的基础上，提供的一种高可用解决方案。哨兵通过监控主从节点的状态，实现自动化的主从切换和故障恢复，减少人工干预。 哨兵的核心功能包括监控、自动故障转移、配置提供和通知。哨兵会持续监控主节点和从节点的运行状态，定期发送 PING 命令检测节点是否正常响应。如果某个节点长时间未响应，哨兵会将其标记为下线。当主节点发生故障时，哨兵会自动从从节点中选举一个新的主节点，并通知其他从节点更新复制目标。同时，哨兵会将新的主节点信息通知客户端，确保客户端能够继续正常工作。 哨兵模式的架构包括主节点、从节点和哨兵节点。主节点负责写操作，从节点负责读操作并作为主节点的备份。哨兵节点是独立运行的进程，负责监控 Redis 集群的状态并执行故障转移。为了避免单点故障，通常需要部署多个哨兵节点（推荐至少 3 个）。 部署哨兵模式时，需要为每个哨兵节点创建配置文件，指定主节点信息和故障转移参数。启动哨兵节点后，哨兵会自动监控主从节点的状态，并在必要时执行故障转移。 Redis 集群模式 Redis 集群模式是一种分布式部署方式，用于解决单机 Redis 在数据量和并发量上的限制。通过集群模式，Redis 可以实现数据分片和高可用性，适用于大规模、高性能的分布式系统。 Redis 集群将整个键空间划分为 16384 个槽（slot）。每个键通过 CRC16 哈希计算后取模，决定其所属的槽。每个节点负责一部分槽，数据分布均匀，避免单点瓶颈。集群通过主从复制实现高可用性，每个主节点可以有一个或多个从节点。当主节点发生故障时，从节点会自动提升为主节点，保证服务的连续性。 Redis 集群是无中心架构，每个节点都保存集群的元数据，并通过 Gossip 协议进行通信和状态同步。相比主从模式和哨兵模式，集群模式支持更大的数据量和更高的并发能力。 集群模式的优点包括水平扩展、高可用性、分布式存储和无中心架构。通过增加节点，可以轻松扩展存储容量和处理能力。主从复制和自动故障转移机制提高了系统的可靠性。分布式存储支持大规模数据存储，避免单机内存限制。无中心架构无需单点控制节点，集群更加稳定。 部署 Redis 集群时，需要准备至少 6 台服务器，每台运行一个 Redis 实例。在每个 Redis 实例的配置文件中，启用集群模式并指定节点端口。启动 Redis 实例后，可以使用 redis-cli 创建集群，并指定主从节点的分布。 总结 Redis 提供了多种高可用和分布式部署方案。主从模式适用于读多写少的场景，提供数据冗余和读写分离。哨兵模式在主从模式的基础上实现自动化故障恢复，适用于高可用性要求较高的系统。集群模式通过数据分片和无中心架构，解决单机性能瓶颈，适用于大规模分布式系统。 根据业务需求选择合适的方案，可以充分发挥 Redis 的性能和优势，构建高可用、高性能的分布式系统。"
  }}
