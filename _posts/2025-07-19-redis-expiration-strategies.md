---
title: Redis Expiration Strategies and Memory Eviction Policies
author: Erkan9527
date: 2025-07-19
category: 技术
layout: post
---

# Redis Expiration Strategies and Memory Eviction Policies

Redis 提供了灵活的过期管理策略和内存淘汰机制，用于高效管理键的生命周期和内存资源。本文记录了 Redis 的过期策略（Expiration Strategies）和内存淘汰策略（Eviction Policies）的核心概念、优缺点及适用场景。

---

## Redis 过期策略

Redis 的过期策略用于管理带有过期时间的键，确保过期数据能够及时清理以释放内存资源。主要包括以下三种策略：

### 定时删除（Fixed Interval Expiration）

**原理**  
为每个设置了过期时间的键创建一个定时器，当键的过期时间到达时，定时器触发并立即删除该键。

**优点**  
- 确保内存及时释放，过期键会在设定时间点被立即移除。
- 避免过期数据长时间占用内存资源。

**缺点**  
- 创建和管理大量定时器会消耗 CPU 资源，尤其是当系统中存在大量带有过期时间的键时，CPU 负载可能显著增加。
- 如果定时器的精度不够高，可能导致键在预期时间之后才被删除。

---

### 惰性删除（Lazy Expiration）

**原理**  
只有在访问某个键时，Redis 才会检查其是否已过期。如果已过期，则删除该键。

**优点**  
- 不会占用额外的 CPU 资源进行检查，只在键被访问时才进行处理。
- 对系统性能的影响较小。

**缺点**  
- 如果键从未被访问，即使已过期，也会一直保留在内存中，导致内存浪费。
- 对于需要频繁访问的数据，可能会导致短时间内大量键被删除，从而影响系统性能。

---

### 混合策略（Combined Policy）

**原理**  
结合定时删除和惰性删除两种策略。Redis 会定期随机抽取一部分带有过期时间的键进行检查，并删除其中已过期的键；同时，在访问键时也会检查其是否已过期，如果已过期则删除该键。

**优点**  
- 既能保证过期键及时被清理，又能尽量减少对系统性能的影响。
- 通过合理设置扫描频率和每次扫描的耗时，可以在不同情况下平衡 CPU 和内存资源的使用。

**缺点**  
- 需要在 CPU 资源和内存资源之间做出权衡。
- 配置复杂度较高，可能需要根据具体的应用场景调整参数以获得最佳效果。

---

## Redis 内存淘汰策略

当 Redis 使用的内存达到预设的最大限制时，内存淘汰策略决定了哪些键值对应该被删除以释放空间。Redis 提供了多种内存淘汰策略，适用于不同的场景和需求。

### 内存淘汰策略列表

1. **noeviction**  
   - 默认策略（≥v3.0）。当内存使用达到最大限制时，Redis 拒绝新的写入操作并返回错误，仅响应读操作。
   - 适用场景：数据保留非常重要且不能丢失，或内存充足的环境。

2. **allkeys-lru**  
   - 在所有键中使用 LRU（最近最少使用）算法进行淘汰。
   - 适用场景：缓存应用，需要保留最近被访问的数据以便快速响应后续请求。

3. **allkeys-lfu**  
   - 在所有键中使用 LFU（最不经常使用）算法进行淘汰。
   - 适用场景：有明显热点数据的应用，确保热点数据不被轻易淘汰。

4. **volatile-lru**  
   - 仅在设置了过期时间的键中，基于 LRU 算法淘汰数据。
   - 适用场景：部分数据有时效性要求，仅针对设置了过期时间的键进行淘汰。

5. **volatile-lfu**  
   - 仅在设置了过期时间的键中，基于 LFU 算法淘汰数据。
   - 适用场景：同样只针对设置了过期时间的键，但淘汰依据是访问频率。

6. **allkeys-random**  
   - 随机从所有键中淘汰数据。
   - 适用场景：对数据淘汰无特定要求。

7. **volatile-random**  
   - 随机从设置了过期时间的键中淘汰数据。
   - 适用场景：仅针对设置了过期时间的键进行随机淘汰。

8. **volatile-ttl**  
   - 根据键的剩余过期时间进行淘汰，越早过期的键越先被淘汰。
   - 适用场景：缓存数据时效性要求严格。

---

## 内存淘汰策略的选择

| 策略名称       | 适用场景                                   | 优点                                   | 缺点                                   |
|----------------|--------------------------------------------|----------------------------------------|----------------------------------------|
| noeviction     | 数据保留重要，内存充足                     | 数据不会被淘汰                         | 达到内存限制后无法写入新数据           |
| allkeys-lru    | 缓存应用，保留最近访问的数据               | 高效淘汰冷数据                         | 需要额外维护 LRU 数据结构              |
| allkeys-lfu    | 热点数据明显，访问频率决定数据重要性       | 确保热点数据不被淘汰                   | 需要额外维护 LFU 数据结构              |
| volatile-lru   | 部分数据有时效性要求                       | 仅淘汰设置了过期时间的键               | 仅适用于部分键有过期时间的场景         |
| volatile-lfu   | 部分数据有时效性要求，访问频率决定淘汰顺序 | 结合时效性和访问频率                   | 配置复杂度较高                         |
| allkeys-random | 无特定淘汰要求                             | 简单随机淘汰                           | 数据淘汰不可控                         |
| volatile-random| 无特定淘汰要求，针对有过期时间的键         | 简单随机淘汰                           | 数据淘汰不可控                         |
| volatile-ttl   | 数据时效性要求严格                         | 优先淘汰即将过期的数据                 | 可能导致频繁淘汰操作                   |

---

## 总结

Redis 的过期策略通过定时删除、惰性删除和混合策略三种方式管理带有过期时间的键，适用于不同的场景和需求。内存淘汰策略则提供了多种方式来优化内存使用，用户可以根据具体需求选择合适的策略。在实际使用中，合理配置过期策略和内存淘汰策略，并结合监控和调优，可以显著提升 Redis 的性能和资源利用率。
